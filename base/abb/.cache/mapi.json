{
    "title": "@abb: \u00c1rvore Bin\u00e1ria de Busca",
    "description": "# \u00c1rvore Bin\u00e1ria de Busca\n\n<!-- toch -->\n[Intro](#intro) | [Draft](#draft) | [Tests](#tests)\n-- | -- | --\n<!-- toch -->\n\n## Intro\n\nNeste exerc\u00edcio, voc\u00ea ir\u00e1 trabalhar com a implementa\u00e7\u00e3o de uma \u00c1rvore Bin\u00e1ria de Busca (ABB), uma varia\u00e7\u00e3o da \u00e1rvore bin\u00e1ria com regras espec\u00edficas de ordena\u00e7\u00e3o. A \u00e1rvore bin\u00e1ria de busca \u00e9 uma estrutura de dados eficiente para opera\u00e7\u00f5es de busca, inser\u00e7\u00e3o e remo\u00e7\u00e3o, sendo amplamente utilizada em algoritmos e sistemas que precisam de organiza\u00e7\u00e3o de dados estruturados.\n\nEm uma \u00c1rvore Bin\u00e1ria de Busca, cada n\u00f3 tem no m\u00e1ximo dois filhos: um filho esquerdo e um filho direito. A regra de ordena\u00e7\u00e3o \u00e9 a seguinte:\n\n- Todos os valores dos n\u00f3s na sub\u00e1rvore esquerda de um n\u00f3 s\u00e3o menores que o valor do pr\u00f3prio n\u00f3.\n- Todos os valores dos n\u00f3s na sub\u00e1rvore direita de um n\u00f3 s\u00e3o maiores que o valor do pr\u00f3prio n\u00f3.\n\nNo arquivo `lib.cpp`, voc\u00ea encontrar\u00e1 a classe `BSTree` que representa a \u00c1rvore Bin\u00e1ria de Busca, com alguns m\u00e9todos j\u00e1 implementados (riscados) e outros que voc\u00ea precisa desenvolver.\n\n- ~~`BSTree()`~~\n- ~~`~BSTree()`~~\n- `Node* search(int info)`\n- `void insert(Node *current, int info)`\n- `int size()`\n- `int min()`\n- `int max()`\n- ~~`void clear()`~~\n- ~~`bool empty()`~~\n- ~~`void print()`~~\n\n## Draft\n\n- Voc\u00ea deve implementar os m\u00e9todos faltantes no arquivo `lib.cpp`\n\n<!-- links .cache/draft -->\n- cpp\n  - [lib.cpp](https://github.com/qxcodeed/arcade/blob/master/base/abb/.cache/draft/cpp/lib.cpp)\n  - [main.cpp](https://github.com/qxcodeed/arcade/blob/master/base/abb/.cache/draft/cpp/main.cpp)\n<!-- links -->\n\n- **Importante**: N\u00e3o altere os m\u00e9todos que j\u00e1 est\u00e3o implementados no arquivo `lib.cpp`. Foque apenas em completar as funcionalidades que est\u00e3o faltando. O arquivo `main()` j\u00e1 est\u00e1 dispon\u00edvel, ent\u00e3o voc\u00ea n\u00e3o precisa se preocupar com a entrada ou sa\u00edda padr\u00e3o.\n\n## Tests\n\n### Entrada\n\n- A entrada para este exerc\u00edcio \u00e9 gerada automaticamente no sistema do Moodle. Voc\u00ea n\u00e3o precisa se preocupar em lidar diretamente com a entrada ou sa\u00edda, pois a \u00e1rvore ser\u00e1 manipulada internamente pelos m\u00e9todos que voc\u00ea implementar.\n\n### Sa\u00edda\n\n- O sistema ir\u00e1 verificar se a sua implementa\u00e7\u00e3o est\u00e1 correta, passando casos de teste autom\u00e1ticos. Seu c\u00f3digo deve garantir que as opera\u00e7\u00f5es de busca, inser\u00e7\u00e3o e c\u00e1lculo de tamanho, m\u00ednimo e m\u00e1ximo funcionem corretamente.\n\n### Dicas para Implementa\u00e7\u00e3o\n\n1. **Busca**: Comece da raiz e percorra a \u00e1rvore seguindo as regras da ABB at\u00e9 encontrar o valor ou atingir um n\u00f3 nulo.\n2. **Inser\u00e7\u00e3o**: Compare o valor a ser inserido com o n\u00f3 atual. Se for menor, v\u00e1 para o filho esquerdo; se for maior, v\u00e1 para o filho direito, inserindo na posi\u00e7\u00e3o correta.\n3. **Tamanho**: Percorra toda a \u00e1rvore e conte o n\u00famero de n\u00f3s.\n4. **M\u00ednimo e M\u00e1ximo**: V\u00e1 para o n\u00f3 mais \u00e0 esquerda para encontrar o m\u00ednimo e para o mais \u00e0 direita para o m\u00e1ximo.\n",
    "upload": [
        {
            "name": "vpl_evaluate.cases",
            "contents": ">>>>>>>> INSERT test_insert\ntest_insert\n======== EXPECT\nTESTE insert\ninsert 40\ninsert 20\ninsert 10\ninsert 30\ninsert 70\nBSTree: Node-40{(Node-20{(Node-10{(, )}, Node-30{(, )})}, Node-70{(, )})}\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_insert_2\ntest_insert_2\n======== EXPECT\nTESTE insert\ninsert 40\ninsert 45\ninsert 20\ninsert 15\ninsert 10\ninsert 30\ninsert 35\ninsert 75\ninsert 70\ninsert 80\ninsert 90\ninsert 5\ninsert 1\ninsert 7\ninsert 2\ninsert 8\ninsert 0\ninsert -10\nBSTree: Node-40{(Node-20{(Node-15{(Node-10{(Node-5{(Node-1{(Node-0{(Node--10{(, )}, )}, Node-2{(, )})}, Node-7{(, Node-8{(, )})})}, )}, )}, Node-30{(, Node-35{(, )})})}, Node-45{(, Node-75{(Node-70{(, )}, Node-80{(, Node-90{(, )})})})})}\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_min_max\ntest_min_max\n======== EXPECT\nTESTE min max\nmin -1\nmax -1\ninsert 40\nmin 40\nmax 40\ninsert 45\nmin 40\nmax 45\ninsert 20\nmin 20\nmax 45\ninsert 10\nmin 10\nmax 45\ninsert 30\nmin 10\nmax 45\ninsert 75\nmin 10\nmax 75\ninsert 70\nmin 10\nmax 75\ninsert 90\nmin 10\nmax 90\ninsert 5\nmin 5\nmax 90\ninsert 1\nmin 1\nmax 90\ninsert 7\nmin 1\nmax 90\ninsert -10\nBSTree: Node-40{(Node-20{(Node-10{(Node-5{(Node-1{(Node--10{(, )}, )}, Node-7{(, )})}, )}, Node-30{(, )})}, Node-45{(, Node-75{(Node-70{(, )}, Node-90{(, )})})})}\nmin -10\nmax 90\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_size\ntest_size\n======== EXPECT\nTESTE size\nsize 0\ninsert 40\nsize 1\ninsert 45\nsize 2\ninsert 20\nsize 3\ninsert 10\nsize 4\ninsert 30\nsize 5\ninsert 75\nsize 6\ninsert 70\nsize 7\ninsert 90\nsize 8\ninsert 5\nsize 9\ninsert 1\nsize 10\ninsert 7\nsize 11\ninsert -10\nBSTree: Node-40{(Node-20{(Node-10{(Node-5{(Node-1{(Node--10{(, )}, )}, Node-7{(, )})}, )}, Node-30{(, )})}, Node-45{(, Node-75{(Node-70{(, )}, Node-90{(, )})})})}\nsize 12\n<<<<<<<< FINISH\n\n",
            "type": "hide"
        }
    ],
    "draft": {
        "cpp": [
            {
                "name": "lib.cpp",
                "contents": "#include <iostream>\n\n// Node: classe utilizada para representar um No\n// Nao altere essa classe\nstruct Node {\n    int info; // Informacao salva pelo usuario na arvore\n    Node *left; // Ponteiro para o No filho a esquerda\n    Node *right; // Ponteiro para o No filho a direita\n\n    // Construtores\n    Node(); \n    Node(int info, Node *left=NULL, Node *right=NULL);\n    \n    // Destrutor\n    ~Node();\n};\n\n// Binary Search Tree ou\n// Arvore de busca binaria\n// Altere somente os campos marcados com TODO\nstruct BSTree {\n    Node *root;   // Ponteiro para o No raiz da arvore\n\n    BSTree() {\n        root = NULL;\n    }\n\n    ~BSTree() { // Destrutor\n        clear();\n    }\n\n    // Retorna o No da arvore que possui sua informacao igual a 'info',\n    // ou retorna um No vazio (NULL) caso a arvore nao possua tal 'info'.\n    Node* search(int info) {\n        // TODO: Complexidade O(h), onde h = altura da arvore\n        (void) info;\n        return nullptr;\n    }\n\n    // Adiciona um elemento na arvore.\n    // Esse novo elemento deve ser inserido no lugar\n    // de um No vazio e ao mesmo tempo respeitar as propriedades\n    // de uma arvore binaria de busca. \n    // info: informacao do elemento a ser inserido\n    void insert(int info) {\n        // TODO: Complexidade O(h), onde h = altura da arvore\n        (void) info;\n        return;\n    }\n    /*\n        Exemplo:\n\n           T =   40\n                /  \\\n               20  70\n              /  \\\n             10  30\n\n        T.insert(90)\n\n           T =   40\n                /  \\\n               20  70\n              /  \\   \\\n             10  30  90\n    */\n\n\n    // Retorna a quantidade de elementos da arvore.\n    int size() {\n        // TODO: Complexidade O(n)\n        return 0;\n    }\n    // Retorna o menor elemento da arvore, ou -1 caso nao exista\n    int min() {\n        // TODO: Complexidade O(h), onde h = altura da arvore\n        return -1;\n    }\n\n\n    // Retorna o maior elemento da arvore, ou -1 caso nao exista\n    int max() {\n        // TODO: Complexidade O(h), onde h = altura da arvore\n        return -1;\n    }\n\n    // Deixa a lista vazia, com zero elementos\n    void clear() {\n        _clear(root);\n        root = nullptr;\n    }\n\n    void _clear(Node* current) {\n        if(current == nullptr) return;\n        _clear(current->left);\n        _clear(current->right);\n        delete current;\n    }\n\n    // Devolve true se vazia e false caso contrario\n    bool empty() {\n        return root == nullptr;\n    }\n\n    // Printa as informacoes da lista\n    void print() {\n        std::cout << \"BSTree: \";\n        _print(root);\n        std::cout << std::endl;\n    }\n\n    void _print(Node *current) {\n        if(current != nullptr) {\n            std::cout << \"Node-\" << current->info << \"{(\";\n            _print(current->left);\n            std::cout << \", \";\n            _print(current->right);\n            std::cout << \")}\";\n        }\n    }\n};\n",
                "type": "show"
            },
            {
                "name": "main.cpp",
                "contents": "// Arquivo de execucao\n#include <iostream>\n#include <map>\n//#include \"solution_lib.cpp\"\n#include \"lib.cpp\"\n\nusing std::cout;\nusing std::endl;\n\nbool LOG_ALLOCATED = false;\nstd::map<void*, int> allocated_nodes_status = {};\nstd::map<int, int> mapa = {};\nconst int ALLOCATED = 1;\nconst int DELETED = 2;\n\n// Salvar Nos alocados\nNode::Node() {\n    allocated_nodes_status[this] = ALLOCATED;\n}\n\nNode::Node(int info, Node* left, Node* right){\n    allocated_nodes_status[this] = ALLOCATED;\n    this->info = info;\n    this->left = left;\n    this->right = right;\n}\nNode::~Node() {\n    allocated_nodes_status[this] = DELETED;\n}\n\ntemplate <typename K, typename V>\nvoid printMap(const std::map<K, V>& m) {\n    for (const auto& pair : m) {\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\n    }\n}\n\n/////////////// TESTES AUXILIARES /////////////\n\nvoid print_node(Node *node){\n    if(node == NULL){\n        cout << \"Node(empty)\" << endl;\n    }else{\n        cout << \"Node(\" << node->info << \")\" << endl;\n    }\n}\n\n/*\n    Exemplo:\n    \n       T =   40\n            /  \\\n           20  70\n          /  \\\n         10  30\n*/\n\n/////////////// TESTE SEARCH ///////////////\n\nvoid test_insert(){\n    cout << \"TESTE insert\" << endl;\n    BSTree tree;\n\n    cout << \"insert 40\" << endl; tree.insert(40);\n    cout << \"insert 20\" << endl; tree.insert(20);\n    cout << \"insert 10\" << endl; tree.insert(10);\n    cout << \"insert 30\" << endl; tree.insert(30);\n    cout << \"insert 70\" << endl; tree.insert(70);\n    tree.print();\n}\n\nvoid test_insert2(){\n    cout << \"TESTE insert\" << endl;\n    BSTree tree;\n\n    cout << \"insert 40\" << endl; tree.insert(40);\n    cout << \"insert 45\" << endl; tree.insert(45);\n    cout << \"insert 20\" << endl; tree.insert(20);\n    cout << \"insert 15\" << endl; tree.insert(15);\n    cout << \"insert 10\" << endl; tree.insert(10);\n    cout << \"insert 30\" << endl; tree.insert(30);\n    cout << \"insert 35\" << endl; tree.insert(35);\n    cout << \"insert 75\" << endl; tree.insert(75);\n    cout << \"insert 70\" << endl; tree.insert(70);\n    cout << \"insert 80\" << endl; tree.insert(80);\n    cout << \"insert 90\" << endl; tree.insert(90);\n    cout << \"insert 5\" << endl; tree.insert(5);\n    cout << \"insert 1\" << endl; tree.insert(1);\n    cout << \"insert 7\" << endl; tree.insert(7);\n    cout << \"insert 2\" << endl; tree.insert(2);\n    cout << \"insert 8\" << endl; tree.insert(8);\n    cout << \"insert 0\" << endl; tree.insert(0);\n    cout << \"insert -10\" << endl; tree.insert(-10);\n    tree.print();\n}\n\n/////////////// TESTE SEARCH ///////////////\n\n/*\n    Exemplo:\n\n       T =   40\n            /  \\\n           20  70\n          /  \\\n         10  30\n*/\n\nvoid test_search(){\n    cout << \"TESTE push_front\" << endl;\n    cout << \"TESTE insert\" << endl;\n    BSTree tree;\n\n    cout << \"insert 40\" << endl; tree.insert(40);\n    cout << \"insert 20\" << endl; tree.insert(20);\n    cout << \"insert 10\" << endl; tree.insert(10);\n    cout << \"insert 30\" << endl; tree.insert(30);\n    cout << \"insert 70\" << endl; tree.insert(70);\n    tree.print();\n\n    cout << \"search 40: \"; print_node(tree.search(40));\n    cout << \"search 20: \"; print_node(tree.search(20));\n    cout << \"search 10: \"; print_node(tree.search(10));\n    cout << \"search 30: \"; print_node(tree.search(30));\n    cout << \"search 70: \"; print_node(tree.search(70));\n\n    cout << \"search -20: \"; print_node(tree.search(-20));\n    cout << \"search 1000: \"; print_node(tree.search(1000));\n    cout << \"search 45: \"; print_node(tree.search(44));\n    cout << \"search 25: \"; print_node(tree.search(25));\n    cout << \"search 35: \"; print_node(tree.search(35));\n    cout << \"search 65: \"; print_node(tree.search(65));\n}\n\n/////////////// TESTE SIZE ///////////////\n\nvoid test_size(){\n    cout << \"TESTE size\" << endl;\n    BSTree tree;\n\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 40\" << endl; tree.insert(40);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 45\" << endl; tree.insert(45);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 20\" << endl; tree.insert(20);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 10\" << endl; tree.insert(10);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 30\" << endl; tree.insert(30);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 75\" << endl; tree.insert(75);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 70\" << endl; tree.insert(70);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 90\" << endl; tree.insert(90);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 5\" << endl; tree.insert(5);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 1\" << endl; tree.insert(1);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 7\" << endl; tree.insert(7);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert -10\" << endl; tree.insert(-10);\n    tree.print();\n    cout << \"size \" << tree.size() << endl;\n}\n\n/////////////// TESTE MIN MAX ///////////////\n\nvoid test_min_max(){\n    cout << \"TESTE min max\" << endl;\n    BSTree tree;\n\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 40\" << endl; tree.insert(40);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 45\" << endl; tree.insert(45);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 20\" << endl; tree.insert(20);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 10\" << endl; tree.insert(10);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 30\" << endl; tree.insert(30);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 75\" << endl; tree.insert(75);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 70\" << endl; tree.insert(70);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 90\" << endl; tree.insert(90);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 5\" << endl; tree.insert(5);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 1\" << endl; tree.insert(1);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 7\" << endl; tree.insert(7);\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert -10\" << endl; tree.insert(-10);\n    tree.print();\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n}\n\n/////////////// FIM TESTES ///////////////\n\nint main(){\n    std::string input;\n    std::cin >> input;\n\n    if(input == \"test_insert\") test_insert();\n    if(input == \"test_insert_2\") test_insert2();\n    if(input == \"test_size\") test_size();\n    if(input == \"test_min_max\") test_min_max();\n}\n",
                "type": "hide"
            }
        ]
    }
}
