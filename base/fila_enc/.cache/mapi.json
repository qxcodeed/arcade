{
    "title": "@fila_enc: Fila usando lista encadeada simples",
    "description": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>@fila_enc: Fila usando lista encadeada simples</title>\n    <style>\n        body { font-family: sans-serif; line-height: 1.6; margin: 20px; }\n        pre { background-color: #f4f4f4; padding: 10px; border-radius: 5px; overflow-x: auto; }\n        code { font-family: monospace; }\n        table { border-collapse: collapse; width: 100%; }\n        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n        th { background-color: #f2f2f2; }\n        /* Estilos b\u00e1sicos para o destaque de sintaxe (gerado pelo pygments via pymdownx.highlight) */\n        .highlight .hll { background-color: #ffffcc }\n        .highlight .c { color: #999988; font-style: italic } /* Comment */\n        .highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */\n        .highlight .k { color: #000000; font-weight: bold } /* Keyword */\n        .highlight .o { color: #000000; font-weight: bold } /* Operator */\n        .highlight .ch { color: #999988; font-style: italic } /* Comment.Hashbang */\n        .highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */\n        .highlight .cp { color: #999999; font-weight: bold; font-style: italic } /* Comment.Preproc */\n        .highlight .cpf { color: #999988; font-style: italic } /* Comment.PreprocFile */\n        .highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */\n        .highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */\n        .highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */\n        .highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */\n        .highlight .gr { color: #aa0000 } /* Generic.Error */\n        .highlight .gh { color: #999999 } /* Generic.Heading */\n        .highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */\n        .highlight .go { color: #888888 } /* Generic.Output */\n        .highlight .gp { color: #555555 } /* Generic.Prompt */\n        .highlight .gs { font-weight: bold } /* Generic.Strong */\n        .highlight .gu { color: #aaaaaa } /* Generic.Subheading */\n        .highlight .gt { color: #aa0000 } /* Generic.Traceback */\n        .highlight .kc { color: #000000; font-weight: bold } /* Keyword.Constant */\n        .highlight .kd { color: #000000; font-weight: bold } /* Keyword.Declaration */\n        .highlight .kn { color: #000000; font-weight: bold } /* Keyword.Namespace */\n        .highlight .kp { color: #000000; font-weight: bold } /* Keyword.Pseudo */\n        .highlight .kr { color: #000000; font-weight: bold } /* Keyword.Reserved */\n        .highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */\n        .highlight .m { color: #009999 } /* Literal.Number */\n        .highlight .s { color: #dd1144 } /* Literal.String */\n        .highlight .na { color: #008080 } /* Name.Attribute */\n        .highlight .nb { color: #0086B3 } /* Name.Builtin */\n        .highlight .nc { color: #445588; font-weight: bold } /* Name.Class */\n        .highlight .no { color: #008080 } /* Name.Constant */\n        .highlight .nd { color: #3c5d5d; font-weight: bold } /* Name.Decorator */\n        .highlight .ni { color: #800080 } /* Name.Entity */\n        .highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */\n        .highlight .nf { color: #990000; font-weight: bold } /* Name.Function */\n        .highlight .nl { color: #990000; font-weight: bold } /* Name.Label */\n        .highlight .nn { color: #555555; font-weight: bold } /* Name.Namespace */\n        .highlight .nx { color: #990000; font-weight: bold } /* Name.Other */\n        .highlight .py { color: #009999 } /* Name.Property */\n        .highlight .p { color: #000000 } /* Name.Punctuation */\n        .highlight .nv { color: #008080 } /* Name.Variable */\n        .highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */\n        .highlight .w { color: #bbbbbb } /* Text.Whitespace */\n        .highlight .mf { color: #009999 } /* Literal.Number.Float */\n        .highlight .mh { color: #009999 } /* Literal.Number.Hex */\n        .highlight .mi { color: #009999 } /* Literal.Number.Integer */\n        .highlight .mo { color: #009999 } /* Literal.Number.Oct */\n        .highlight .sb { color: #dd1144 } /* Literal.String.Backtick */\n        .highlight .sc { color: #dd1144 } /* Literal.String.Char */\n        .highlight .sd { color: #dd1144 } /* Literal.String.Doc */\n        .highlight .s2 { color: #dd1144 } /* Literal.String.Double */\n        .highlight .se { color: #dd1144 } /* Literal.String.Escape */\n        .highlight .sh { color: #dd1144 } /* Literal.String.Heredoc */\n        .highlight .si { color: #dd1144 } /* Literal.String.Interpol */\n        .highlight .sx { color: #dd1144 } /* Literal.String.Other */\n        .highlight .sr { color: #009926 } /* Literal.String.Regex */\n        .highlight .s1 { color: #dd1144 } /* Literal.String.Single */\n        .highlight .ss { color: #dd1144 } /* Literal.String.Symbol */\n        .highlight .bp { color: #0086B3 } /* Name.Builtin.Pseudo */\n        .highlight .vc { color: #008080 } /* Name.Variable.Class */\n        .highlight .vg { color: #008080 } /* Name.Variable.Global */\n        .highlight .vi { color: #008080 } /* Name.Variable.Instance */\n        .highlight .il { color: #009999 } /* Literal.Number.Integer.Long */\n    </style>\n    <script type=\"text/javascript\" async\n      src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML\">\n    </script>\n</head>\n<body>\n<h1>Fila usando lista encadeada simples</h1>\n<!-- toch -->\n<table>\n<thead>\n<tr>\n<th><a href=\"#intro\">Intro</a></th>\n<th><a href=\"#draft\">Draft</a></th>\n<th><a href=\"#shell\">Shell</a></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<!-- toch -->\n\n<h2>Intro</h2>\n<p>Neste exerc\u00edcio, voc\u00ea implementar\u00e1 uma <strong>Fila</strong> utilizando uma <strong>Lista Simplesmente Encadeada</strong>. Fila \u00e9 uma estrutura de dados linear que segue o princ\u00edpio FIFO (<strong>First In, First Out</strong>), onde o primeiro elemento inserido \u00e9 tamb\u00e9m o primeiro a ser removido.</p>\n<p>Na implementa\u00e7\u00e3o de uma fila encadeada, cada n\u00f3 cont\u00e9m uma informa\u00e7\u00e3o e um ponteiro para o pr\u00f3ximo elemento. A estrutura da fila \u00e9 composta por:</p>\n<ul>\n<li><code>head</code>: ponteiro para o primeiro n\u00f3 da fila. \u00c9 utilizado para remover elementos da fila.</li>\n<li><code>tail</code>: ponteiro para o \u00faltimo n\u00f3 da fila. \u00c9 utilizado para adicionar novos elementos \u00e0 fila.</li>\n</ul>\n<p>Cada opera\u00e7\u00e3o de inser\u00e7\u00e3o e remo\u00e7\u00e3o na fila deve atualizar o atributo <code>size</code>, que representa o n\u00famero de elementos na fila. Sua fila n\u00e3o deve utilizar n\u00f3s de marca\u00e7\u00e3o, ou seja, n\u00e3o deve haver n\u00f3s que n\u00e3o contenham dados v\u00e1lidos. Todas as opera\u00e7\u00f5es devem ser implementadas de forma eficiente.</p>\n<h3>Complexidade das opera\u00e7\u00f5es</h3>\n<ul>\n<li>Inser\u00e7\u00e3o (<code>push</code>): O(1) - Adiciona um elemento ao final da fila (enqueue).</li>\n<li>Remo\u00e7\u00e3o (<code>pop</code>): O(1) - Remove o elemento do in\u00edcio da fila (dequeue).</li>\n<li>Verifica\u00e7\u00e3o do tamanho (<code>size</code>): O(1) - Retorna o n\u00famero de elementos na fila.</li>\n<li>Verifica\u00e7\u00e3o se a fila est\u00e1 vazia (<code>isEmpty</code>): O(1) - Retorna verdadeiro se n\u00e3o h\u00e1 elementos na fila.</li>\n<li>Visualiza\u00e7\u00e3o do primeiro elemento (<code>peek</code>): O(1) - Retorna o primeiro elemento sem remov\u00ea-lo.</li>\n<li>Visualiza\u00e7\u00e3o do estado da fila (<code>show</code>): O(n) - Retorna uma representa\u00e7\u00e3o em string dos elementos da fila para debug.</li>\n</ul>\n<h2>Draft</h2>\n<!-- links .cache/draft -->\n<ul>\n<li>cpp<ul>\n<li><a href=\"https://github.com/qxcodeed/arcade/blob/master/base/fila_enc/.cache/draft/cpp/lib.cpp\">lib.cpp</a></li>\n<li><a href=\"https://github.com/qxcodeed/arcade/blob/master/base/fila_enc/.cache/draft/cpp/main.cpp\">main.cpp</a></li>\n</ul>\n</li>\n<li>go<ul>\n<li><a href=\"https://github.com/qxcodeed/arcade/blob/master/base/fila_enc/.cache/draft/go/main.go\">main.go</a></li>\n</ul>\n</li>\n</ul>\n<!-- links -->\n\n<h2>Shell</h2>\n<div class=\"language-bash highlight\"><pre><span></span><code><span class=\"c1\">#TEST_CASE 01</span>\n<span class=\"nv\">$push</span><span class=\"w\"> </span><span class=\"m\">4</span>\n<span class=\"nv\">$push</span><span class=\"w\"> </span><span class=\"m\">5</span>\n<span class=\"nv\">$push</span><span class=\"w\"> </span><span class=\"m\">6</span>\n<span class=\"nv\">$show</span>\n<span class=\"o\">[</span><span class=\"m\">4</span>,<span class=\"w\"> </span><span class=\"m\">5</span>,<span class=\"w\"> </span><span class=\"m\">6</span><span class=\"o\">]</span>\n<span class=\"nv\">$end</span>\n</code></pre></div>\n<div class=\"language-bash highlight\"><pre><span></span><code><span class=\"c1\">#TEST_CASE 02</span>\n<span class=\"nv\">$push</span><span class=\"w\"> </span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"m\">5</span><span class=\"w\"> </span><span class=\"m\">7</span><span class=\"w\"> </span><span class=\"m\">8</span>\n<span class=\"nv\">$show</span>\n<span class=\"o\">[</span><span class=\"m\">1</span>,<span class=\"w\"> </span><span class=\"m\">3</span>,<span class=\"w\"> </span><span class=\"m\">5</span>,<span class=\"w\"> </span><span class=\"m\">7</span>,<span class=\"w\"> </span><span class=\"m\">8</span><span class=\"o\">]</span>\n<span class=\"nv\">$pop</span>\n<span class=\"nv\">$show</span>\n<span class=\"o\">[</span><span class=\"m\">3</span>,<span class=\"w\"> </span><span class=\"m\">5</span>,<span class=\"w\"> </span><span class=\"m\">7</span>,<span class=\"w\"> </span><span class=\"m\">8</span><span class=\"o\">]</span>\n<span class=\"nv\">$pop</span>\n<span class=\"nv\">$show</span>\n<span class=\"o\">[</span><span class=\"m\">5</span>,<span class=\"w\"> </span><span class=\"m\">7</span>,<span class=\"w\"> </span><span class=\"m\">8</span><span class=\"o\">]</span>\n<span class=\"nv\">$end</span>\n</code></pre></div>\n<div class=\"language-bash highlight\"><pre><span></span><code><span class=\"c1\">#TEST_CASE 03</span>\n<span class=\"nv\">$push</span><span class=\"w\"> </span><span class=\"m\">10</span>\n<span class=\"nv\">$push</span><span class=\"w\"> </span><span class=\"m\">20</span>\n<span class=\"nv\">$push</span><span class=\"w\"> </span><span class=\"m\">30</span>\n<span class=\"nv\">$peek</span>\n<span class=\"m\">10</span>\n<span class=\"nv\">$pop</span>\n<span class=\"nv\">$peek</span>\n<span class=\"m\">20</span>\n<span class=\"nv\">$pop</span>\n<span class=\"nv\">$peek</span>\n<span class=\"m\">30</span>\n<span class=\"nv\">$pop</span>\n<span class=\"nv\">$peek</span>\nfalha:<span class=\"w\"> </span>fila<span class=\"w\"> </span>vazia\n<span class=\"nv\">$pop</span>\nfalha:<span class=\"w\"> </span>fila<span class=\"w\"> </span>vazia\n<span class=\"nv\">$end</span>\n</code></pre></div>\n</body>\n</html>\n",
    "upload": [
        {
            "name": "vpl_evaluate.cases",
            "contents": ">>>>>>>> INSERT 01\npush 4\npush 5\npush 6\nshow\nend\n======== EXPECT\n$push 4\n$push 5\n$push 6\n$show\n[4, 5, 6]\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT 02\npush 1 3 5 7 8\nshow\npop\nshow\npop\nshow\nend\n======== EXPECT\n$push 1 3 5 7 8\n$show\n[1, 3, 5, 7, 8]\n$pop\n$show\n[3, 5, 7, 8]\n$pop\n$show\n[5, 7, 8]\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT 03\npush 10\npush 20\npush 30\npeek\npop\npeek\npop\npeek\npop\npeek\npop\nend\n======== EXPECT\n$push 10\n$push 20\n$push 30\n$peek\n10\n$pop\n$peek\n20\n$pop\n$peek\n30\n$pop\n$peek\nfalha: fila vazia\n$pop\nfalha: fila vazia\n$end\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT Teste do peek\ntest_peek\n======== EXPECT\nTESTE peek\n[]\npush 10\npeek == 10\npush 15\npeek == 10\npush 20\npeek == 10\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT Teste do push\ntest_push\n======== EXPECT\nTESTE push\npush 10\npush 15\npush 20\npush 25\nEsperado: [10 -> 15 -> 20 -> 25]\nFila: [10 -> 15 -> 20 -> 25]\n4 Nos alocados\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT Teste do pop\ntest_pop\n======== EXPECT\nTESTE pop\nFila: [10 -> 15 -> 20 -> 25 -> 30]\npop\nFila: [15 -> 20 -> 25 -> 30]\npop\nFila: [20 -> 25 -> 30]\npop\nFila: [25 -> 30]\npop\nFila: [30]\npop\nFila: []\nTodos os Nos foram devidamente deletados\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT Teste completo\ntest_all\n======== EXPECT\nTESTE todos (push, pop, peek, size)\npush 1\nFila: [1]\npush 2\nFila: [1 -> 2]\npush 3\nFila: [1 -> 2 -> 3]\npop\nFila: [2 -> 3]\npop\nFila: [3]\npush 4\nFila: [3 -> 4]\npush 5\nFila: [3 -> 4 -> 5]\npop\nFila: [4 -> 5]\npop\nFila: [5]\npush 6\nFila: [5 -> 6]\npush 7\nFila: [5 -> 6 -> 7]\npush 8\nFila: [5 -> 6 -> 7 -> 8]\npop\nFila: [6 -> 7 -> 8]\npop\nFila: [7 -> 8]\nLista: [7 -> 8]\nsize: 2\n<<<<<<<< FINISH\n\n",
            "type": "hide"
        }
    ],
    "draft": {
        "cpp": [
            {
                "name": "lib.cpp",
                "contents": "#include <iostream>\n\n// Node: classe utilizada para representar um No\n// NAO ALTERE ESSA CLASSE\nstruct Node {\n    int info; // Informacao salva pelo usuario na lista\n    Node *next; // Ponteiro para o proximo elemento da lista\n\n    Node(); // Construtor\n    Node(int info, Node *next = nullptr); // Construtor\n    \n    ~Node(); // Destrutor\n};\n\n// Queue ou Pilha\n// Altere somente os campos marcados com TODO\nstruct LinkedQueue {\n    Node *front; // Ponteiro para a cabeca da lista (primeiro No)\n    Node *back;  // Ponteiro para a cauda da lista (ultimo No)\n    int size;    // Quantidade de elementos da fila (salvar esse valor permite sua consulta em O(1))\n\n    LinkedQueue() {\n        front = nullptr;\n        back = nullptr;\n        size = 0;\n    }\n\n    ~LinkedQueue(){\n        clear();\n    }\n\n\n    // Adiciona um elemento no topo da fila\n    // info: informacao do elemento a ser inserido\n    void push(int info) {\n        // TODO\n        (void) info;\n    }\n\n\n    // Remove um elemento do topo da fila.\n    // Nao faz nada caso a fila esteja vazia.\n    void pop(){\n        // TODO\n    }\n\n\n    // Retorna a informacao do elemento na frente da fila.\n    // Retorna -1, caso a fila esteja vazia.\n    int peek(){\n        // TODO\n        return -1;\n    }\n\n\n    // Remove todos os elementos da fila\n    void clear(){\n        // TODO\n    }\n\n\n    // Devolve true se cheia e false caso contrario\n    bool empty(){\n        return front == nullptr;\n    }\n\n\n    // Printa as informacoes da lista\n    void print(){\n        std::cout << \"[\";\n        for(Node* node = front; node != NULL; node = node->next){\n            std::cout << node->info;\n            if(node->next != NULL)\n                std::cout << \" -> \";\n        }\n        std::cout << \"]\" << std::endl;\n    }    \n};\n",
                "type": "show"
            },
            {
                "name": "main.cpp",
                "contents": "#include <iostream>\n#include <map>\n#include \"lib.cpp\"\n\nusing std::cout;\nusing std::endl;\n\nbool LOG_ALLOCATED = false;\nstd::map<void*, int> allocated_nodes_status = {};\nstd::map<int, int> mapa = {};\nconst int ALLOCATED = 1;\nconst int DELETED = 2;\n\n// Salvar Nos alocados\nNode::Node() {\n    allocated_nodes_status[this] = ALLOCATED;\n}\n\nNode::Node(int info, Node* next) {\n    allocated_nodes_status[this] = ALLOCATED;\n    this->info = info;\n    this->next = next;\n}\nNode::~Node() {\n    allocated_nodes_status[this] = DELETED;\n}\n\ntemplate <typename K, typename V>\nvoid printMap(const std::map<K, V>& m) {\n    for (const auto& pair : m) {\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\n    }\n}\n\n/////////////// TESTE CONSTRUCT ///////////////\n\nvoid test_constructor() {\n    cout << \"TESTE Construtor\" << endl;\n    LinkedQueue* queue = new LinkedQueue(); \n\n    if(queue->front == nullptr && queue->size == 0){\n        cout << \"Ok\" << endl;\n    }else{\n        cout << \"Atributos incorretos\";\n    }\n}\n\n\nvoid push_test(LinkedQueue &queue, int info) {\n    if(queue.front == nullptr) {\n        queue.front = queue.back = new Node(info, nullptr);\n    } else {\n        auto nnode = new Node(info, nullptr);\n        queue.back->next = nnode;\n        queue.back = nnode;\n    }\n}\n\nint peek_test(LinkedQueue &queue) {\n    if(queue.front == nullptr) {\n        return -1;\n    } else {\n        return queue.front->info;\n    }\n}\n\n/////////////// TESTE HAS_INFO ///////////////\n\nvoid test_peek() {\n    cout << \"TESTE peek\" << endl;\n    LinkedQueue queue;\n    \n    queue.print();\n\n    push_test(queue, 10);\n    cout << \"push 10\" << endl;\n    cout << \"peek == \" << queue.peek() << endl;\n\n    push_test(queue, 15);\n    cout << \"push 15\" << endl;\n    cout << \"peek == \" << queue.peek() << endl;\n    \n    push_test(queue, 20);\n    cout << \"push 20\" << endl;\n    cout << \"peek == \" << queue.peek() << endl;\n}\n\n\n/////////////// TESTE PUSH ///////////////\n\nvoid test_push() {\n    allocated_nodes_status.clear();\n    cout << \"TESTE push\" << endl;\n    LinkedQueue queue;\n\n    queue.push(10);\n    cout << \"push \" << 10 << endl;\n\n    queue.push(15);\n    cout << \"push \" << 15 << endl;\n\n    queue.push(20);\n    cout << \"push \" << 20 << endl;\n\n    queue.push(25);\n    cout << \"push \" << 25 << endl;\n\n    cout << \"Esperado: [10 -> 15 -> 20 -> 25]\" << endl;\n    cout << \"Fila: \"; queue.print();\n    cout << allocated_nodes_status.size() << \" Nos alocados\" << endl;\n}\n\n/////////////// TESTE POP ///////////////\n\nvoid test_pop() {\n    cout << \"TESTE pop\" << endl;\n    LinkedQueue queue;\n\n    push_test(queue, 10);\n    push_test(queue, 15);\n    push_test(queue, 20);\n    push_test(queue, 25);\n    push_test(queue, 30);\n\n    Node *node1 = queue.front;\n    Node *node2 = node1->next;\n    Node *node3 = node2->next;\n    Node *node4 = node3->next;\n    Node *node5 = node4->next;\n\n    cout << \"Fila: \"; queue.print();\n\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n\n    bool all_nodes_deleted =    allocated_nodes_status[node1] == DELETED &&\n                                allocated_nodes_status[node2] == DELETED &&\n                                allocated_nodes_status[node3] == DELETED &&\n                                allocated_nodes_status[node4] == DELETED &&\n                                allocated_nodes_status[node5] == DELETED;\n\n    if(all_nodes_deleted) {\n        cout << \"Todos os Nos foram devidamente deletados\" << endl;\n    } else {\n        cout << \"Existem Nos removidos da fila que nao foram liberados na memoria\" << endl;\n    }\n}\n\n/////////////// TESTE CLEAR ///////////////\n\nvoid test_clear() {}\n\n/////////////// TESTE SIZE ///////////////\n\nvoid test_all() {\n    cout << \"TESTE todos (push, pop, peek, size)\" << endl;\n    LinkedQueue queue;\n    int x = 1;\n    \n    cout << \"push \" << x << endl; queue.push(x); x++;\n    cout << \"Fila: \"; queue.print();\n    cout << \"push \" << x << endl; queue.push(x); x++;\n    cout << \"Fila: \"; queue.print();\n    cout << \"push \" << x << endl; queue.push(x); x++;\n    cout << \"Fila: \"; queue.print();\n\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n    \n    cout << \"push \" << x << endl; queue.push(x); x++;\n    cout << \"Fila: \"; queue.print();\n    cout << \"push \" << x << endl; queue.push(x); x++;\n    cout << \"Fila: \"; queue.print();\n\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n    \n    cout << \"push \" << x << endl; queue.push(x); x++;\n    cout << \"Fila: \"; queue.print();\n    cout << \"push \" << x << endl; queue.push(x); x++;\n    cout << \"Fila: \"; queue.print();\n    cout << \"push \" << x << endl; queue.push(x); x++;\n    cout << \"Fila: \"; queue.print();\n\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n    cout << \"pop\" << endl; queue.pop();\n    cout << \"Fila: \"; queue.print();\n\n    cout << \"Lista: \"; queue.print();\n    cout << \"size: \" << queue.size << endl;\n}\n\n/////////////// FIM TESTES ///////////////\n\nint main() {\n    std::string input;\n    std::cin >> input;\n\n    if(input == \"test_peek\") test_peek();\n    if(input == \"test_push\") test_push();\n    if(input == \"test_pop\") test_pop();\n    if(input == \"test_all\") test_all();\n}\n",
                "type": "show"
            }
        ],
        "go": [
            {
                "name": "main.go",
                "contents": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\n// func (q *Queue[T]) Enqueue(value T)\n// func (q *Queue[T]) Dequeue() (T, bool)\n// func (q *Queue[T]) Peek() (T, bool)\n// func (q *Queue[T]) Size() int\n// func (q *Queue[T]) IsEmpty() bool\n// func (q *Queue[T]) Clear()\n\n\ntype Node[T any] struct {\n\tValue T\n\tnext  *Node[T]\n}\n\ntype Queue[T any] struct {\n\thead *Node[T]\n\ttail *Node[T]\n\tsize int\n}\n\nfunc NewQueue[T any]() *Queue[T] {\n\treturn &Queue[T]{}\n}\n\nfunc (q *Queue[T]) String() string {\n\tresult := \"[\"\n\tfor n := q.head; n != nil; n = n.next {\n\t\tif n != q.head {\n\t\t\tresult += \", \"\n\t\t}\n\t\tresult += fmt.Sprintf(\"%v\", n.Value)\n\t}\n\treturn result + \"]\"\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tqueue := NewQueue[int]()\n\n\tfor {\n\t\tif !scanner.Scan() {\n\t\t\tbreak\n\t\t}\n\t\tline := scanner.Text()\n\t\tfmt.Println(\"$\" + line)\n\t\targs := strings.Fields(line)\n\t\tif len(args) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tswitch args[0] {\n\t\tcase \"end\":\n\t\t\tbreak\n\t\tcase \"show\":\n\t\t\tfmt.Println(queue)\n\t\tcase \"push\":\n\t\t\t// for _, arg := range args[1:] {\n\t\t\t// \tvalue, _ := strconv.Atoi(arg)\n\t\t\t// \tqueue.Enqueue(value)\n\t\t\t// }\n\t\tcase \"pop\":\n\t\t\t// if _, ok := queue.Dequeue(); !ok {\n\t\t\t// \tfmt.Println(\"falha: fila vazia\")\n\t\t\t// }\n\t\tcase \"peek\":\n\t\t\t// if value, ok := queue.Peek(); ok {\n\t\t\t// \tfmt.Println(value)\n\t\t\t// } else {\n\t\t\t// \tfmt.Println(\"falha: fila vazia\")\n\t\t\t// }\n\t\tdefault:\n\t\t\tfmt.Println(\"Unknown command:\", args[0])\n\t\t}\n\t}\n}\n",
                "type": "show"
            }
        ]
    }
}
