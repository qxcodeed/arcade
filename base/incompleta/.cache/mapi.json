{
    "title": "@incompleta: Arvore incompleta",
    "description": "\n        <!DOCTYPE html>\n        <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n            <title>@incompleta: Arvore incompleta</title>\n            <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css\">\n        </head>\n        <body>\n            <h1>@incompleta: Arvore incompleta</h1>\n            <h1 id=\"arvore-incompleta\">Arvore incompleta</h1>\n<!-- toch -->\n<table>\n<thead>\n<tr>\n<th><a href=\"#intro\">Intro</a></th>\n<th><a href=\"#draft\">Draft</a></th>\n<th><a href=\"#tests\">Tests</a></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<!-- toch -->\n\n<h2 id=\"intro\">Intro</h2>\n<p>Neste exerc\u00edcio, voc\u00ea ir\u00e1 treinar a atribui\u00e7\u00e3o de valores relacionados a cada n\u00f3 de uma \u00e1rvore bin\u00e1ria. A \u00e1rvore \u00e9 composta por n\u00f3s, onde cada n\u00f3 pode ter um filho \u00e0 esquerda e um filho \u00e0 direita. Al\u00e9m disso, cada n\u00f3 possui os seguintes atributos adicionais:</p>\n<ul>\n<li><code>Node *parent</code>: um ponteiro para o n\u00f3 pai.</li>\n<li><code>int size</code>: o tamanho da sub\u00e1rvore enraizada nesse n\u00f3.</li>\n<li><code>int level</code>: o n\u00edvel do n\u00f3 na \u00e1rvore (come\u00e7ando em 0 para a raiz).</li>\n<li><code>int height</code>: a altura da sub\u00e1rvore enraizada nesse n\u00f3.</li>\n</ul>\n<p>A \u00e1rvore \u00e9 iniciada sem esses valores atribu\u00eddos, e sua tarefa \u00e9 implementar o m\u00e9todo <code>fill()</code> para preencher corretamente essas informa\u00e7\u00f5es. Este m\u00e9todo deve ser capaz de percorrer a \u00e1rvore e calcular os valores de cada n\u00f3 de maneira recursiva.</p>\n<p><strong>Importante</strong>: N\u00e3o altere os m\u00e9todos j\u00e1 implementados no arquivo <code>lib.cpp</code>. Voc\u00ea deve se concentrar apenas em implementar as funcionalidades que est\u00e3o faltando. O arquivo principal <code>main()</code> j\u00e1 est\u00e1 implementado, ent\u00e3o voc\u00ea n\u00e3o precisa se preocupar com isso.</p>\n<h2 id=\"draft\">Draft</h2>\n<ul>\n<li>Voc\u00ea deve implementar a fun\u00e7\u00e3o <code>fill()</code> no arquivo <code>lib.cpp</code> para que os atributos <code>parent</code>, <code>size</code>, <code>level</code> e <code>height</code> sejam corretamente atribu\u00eddos a cada n\u00f3 da \u00e1rvore.</li>\n</ul>\n<!-- links .cache/draft -->\n<ul>\n<li>cpp</li>\n<li><a href=\"https://github.com/qxcodeed/arcade/blob/master/base/incompleta/.cache/draft/cpp/lib.cpp\">lib.cpp</a></li>\n<li><a href=\"https://github.com/qxcodeed/arcade/blob/master/base/incompleta/.cache/draft/cpp/main.cpp\">main.cpp</a></li>\n</ul>\n<!-- links -->\n\n<h2 id=\"tests\">Tests</h2>\n<h3 id=\"entrada\">Entrada</h3>\n<ul>\n<li>A entrada consistir\u00e1 na constru\u00e7\u00e3o da \u00e1rvore bin\u00e1ria, onde cada n\u00f3 \u00e9 representado por sua refer\u00eancia na mem\u00f3ria. N\u00e3o \u00e9 necess\u00e1rio se preocupar com a entrada padr\u00e3o, pois a \u00e1rvore ser\u00e1 criada automaticamente pelo sistema.</li>\n</ul>\n<h3 id=\"saida\">Sa\u00edda</h3>\n<ul>\n<li>Ap\u00f3s a execu\u00e7\u00e3o do seu m\u00e9todo <code>fill()</code>, a \u00e1rvore deve ter todos os n\u00f3s preenchidos corretamente com os valores de <code>parent</code>, <code>size</code>, <code>level</code> e <code>height</code>. Voc\u00ea deve garantir que, ao imprimir a \u00e1rvore, os valores atribu\u00eddos estejam corretos e representem a estrutura da \u00e1rvore.</li>\n</ul>\n<h3 id=\"dicas-para-implementacao\">Dicas para Implementa\u00e7\u00e3o</h3>\n<ol>\n<li><strong>N\u00edvel</strong>: O n\u00edvel de um n\u00f3 pode ser calculado com base no n\u00edvel do n\u00f3 pai, aumentando em 1 para cada n\u00edvel descendo na \u00e1rvore.</li>\n<li><strong>Tamanho</strong>: O tamanho de um n\u00f3 deve ser igual a 1 (contando ele mesmo) mais o tamanho de suas sub\u00e1rvores esquerda e direita.</li>\n<li><strong>Altura</strong>: A altura de um n\u00f3 pode ser calculada como 1 (contando ele mesmo) mais a altura da sub\u00e1rvore mais alta entre suas duas sub\u00e1rvores.</li>\n</ol>\n<h3 id=\"exemplos\">Exemplos</h3>\n<p>Considere a seguinte \u00e1rvore bin\u00e1ria:</p>\n<pre class=\"codehilite\"><code class=\"language-txt\">        A\n       / \\\n      B   C\n     / \\\n    D   E\n</code></pre>\n\n<p>Ap\u00f3s a implementa\u00e7\u00e3o do m\u00e9todo <code>fill()</code>, voc\u00ea deve ser capaz de acessar e imprimir as informa\u00e7\u00f5es dos n\u00f3s:</p>\n<pre class=\"codehilite\"><code class=\"language-txt\">No: A\nParent: NULL\nSize: 5\nLevel: 0\nHeight: 2\n\nNo: B\nParent: A\nSize: 3\nLevel: 1\nHeight: 1\n\nNo: C\nParent: A\nSize: 1\nLevel: 1\nHeight: 0\n\nNo: D\nParent: B\nSize: 1\nLevel: 2\nHeight: 0\n\nNo: E\nParent: B\nSize: 1\nLevel: 2\nHeight: 0\n</code></pre>\n\n<p>A correta implementa\u00e7\u00e3o do m\u00e9todo <code>fill()</code> deve garantir que todas as informa\u00e7\u00f5es estejam coerentes com a estrutura da \u00e1rvore.</p>\n            <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js\"></script>\n            <script>hljs.highlightAll();</script>\n        </body>\n        </html>\n        ",
    "upload": [
        {
            "name": "vpl_evaluate.cases",
            "contents": ">>>>>>>> INSERT test_fill\ntest_fill\n======== EXPECT\nTESTE fill\ninsert 32\ninsert 45\ninsert 37\ninsert 10\ninsert 12\nBinaryTree: Node-32{(Node-45{(Node-10{(, )}, Node-37{(, )})}, Node-12{(, )})}\nfill\nNode(32, -1, 5, 1, 3)\nNode(45, 32, 3, 2, 2)\nNode(10, 45, 1, 3, 1)\nNode(37, 45, 1, 3, 1)\nNode(12, 32, 1, 2, 1)\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_fill_2\ntest_fill_2\n======== EXPECT\nTESTE fill 2\nBinaryTree: Node-32{(Node-11{(Node-6{(, )}, Node-2{(, )})}, Node-112{(Node-63{(Node-66{(, )}, Node-11{(Node--45{(, )}, Node-19{(Node--1000{(, )}, Node-1223{(, )})})})}, Node-21{(, )})})}\nfill\nNode(32, -1, 13, 1, 6)\nNode(11, 32, 3, 2, 2)\nNode(6, 11, 1, 3, 1)\nNode(2, 11, 1, 3, 1)\nNode(112, 32, 9, 2, 5)\nNode(63, 112, 7, 3, 4)\nNode(66, 63, 1, 4, 1)\nNode(11, 63, 5, 4, 3)\nNode(-45, 11, 1, 5, 1)\nNode(19, 11, 3, 5, 2)\nNode(-1000, 19, 1, 6, 1)\nNode(1223, 19, 1, 6, 1)\nNode(21, 112, 1, 3, 1)\n<<<<<<<< FINISH\n\n",
            "encoding": 0
        }
    ],
    "keep": [],
    "required": [],
    "draft": {
        "cpp": [
            {
                "name": "lib.cpp",
                "contents": "#include <iostream>\n\n// Node: classe utilizada para representar um No\n// Nao altere essa classe\nstruct Node {\n    int info; // Informacao salva pelo usuario na arvore\n    Node *left; // Ponteiro para o No filho a esquerda\n    Node *right; // Ponteiro para o No filho a direita\n\n    // CAMPOS FALTANTES QUE VOCE DEVE PREENCHER NO METODO 'FILL' //\n    Node *parent; // Ponteiro para o No pai (nao iniciado)\n    int size; // Quantidade de Nos de sua sub arvore (nao iniciado)\n    int level; // Nivel do No atual em relacao ao No raiz (nao iniciado)\n    int height; // Altura do No atual (nao iniciado)\n\n    // Construtores\n    Node(); \n    Node(int info, Node *left=NULL, Node *right=NULL);\n    \n    // Destrutor\n    ~Node();\n};\n\n// Binary Search Tree ou\n// Arvore de busca binaria\n// Altere somente os campos marcados com TODO\nstruct BinaryTree {\n    Node *root;   // Ponteiro para o No raiz da arvore\n\n    BinaryTree() {\n        root = NULL;\n    }\n\n    // Dado uma arvore onde os Nos foram iniciados com apenas os valores\n    // de 'left' e 'right', sua tarefa consiste em preencher os valores\n    // faltantes de 'parent', 'level', 'height' e 'size'.\n    void fill() {\n        // TODO: Complexidade O(n)\n        // Dica: Voce pode implementar e chamar os\n        // seguintes metodos:\n        // fill_parent(root, NULL);\n        // fill_size(root);\n        // fill_level(root, 1);\n        // fill_height(root);\n        // Mas sinta-se a vontade para alterar os metodos auxiliares.\n    }\n\n    void fill_parent(Node* current, Node* parent) {\n        // TODO: Complexidade O(n)\n        (void) parent;\n        (void) current;\n    }\n\n    int fill_size(Node* current) {\n        // TODO: Complexidade O(n)\n        (void) current;\n        return 0;\n    }\n\n\n    void fill_level(Node* current, int level) {\n        // TODO: Complexidade O(n)\n        (void) current;\n        (void) level;\n    }\n\n\n    int fill_height(Node* current) {\n        // TODO: Complexidade O(n)\n        (void) current;\n        return 0;\n    }\n\n\n    // Exemplo do FILL:\n    /*\n        T =     32\n               /  \\\n              45  12\n             /  \\\n            10  37\n    */\n    //\n    //\n    //  No45 = T.root.left\n    //  No45.parent == NULL\n    //  No45.size == -1\n    //  No45.level == -1\n    //  No45.height == -1\n    //  \n    //  T.fill()  \n    //\n    //  No45.parent == T.root\n    //  No45.size == 3\n    //  No45.level == 2\n    //  No45.height == 2\n    //  \n\n    // Deixa a lista vazia, com zero elementos\n    void clear() {\n        _clear(root);\n        root = NULL;\n    }\n\n    void _clear(Node* current) {\n        if(current == NULL) return;\n        _clear(current->left);\n        _clear(current->right);\n        delete current;\n    }\n\n    // Devolve true se vazia e false caso contrario\n    bool empty() {\n        return root == NULL;\n    }\n\n    // Printa as informacoes da lista\n    void print() {\n        std::cout << \"BinaryTree: \";\n        _print(root);\n        std::cout << std::endl;\n    }\n\n    void _print(Node *current) {\n        if(current != NULL) {\n            std::cout << \"Node-\" << current->info << \"{(\";\n            _print(current->left);\n            std::cout << \", \";\n            _print(current->right);\n            std::cout << \")}\";\n        }\n    }\n};\n",
                "encoding": 0
            },
            {
                "name": "main.cpp",
                "contents": "// Arquivo de execucao\n#include <iostream>\n#include <map>\n//#include \"solution_lib.cpp\"\n#include \"lib.cpp\"\n\nusing std::cout;\nusing std::endl;\n\nbool LOG_ALLOCATED = false;\nstd::map<void*, int> allocated_nodes_status = {};\nstd::map<int, int> mapa = {};\nconst int ALLOCATED = 1;\nconst int DELETED = 2;\n\n// Salvar Nos alocados\nNode::Node() {\n    allocated_nodes_status[this] = ALLOCATED;\n}\n\nNode::Node(int info, Node* left, Node* right) {\n    allocated_nodes_status[this] = ALLOCATED;\n    this->info = info;\n    this->left = left;\n    this->right = right;\n    \n    this->parent = nullptr;\n    this->height = -1;\n    this->size = -1;\n    this->level = -1;\n}\nNode::~Node() {\n    allocated_nodes_status[this] = DELETED;\n}\n\ntemplate <typename K, typename V>\nvoid printMap(const std::map<K, V>& m) {\n    for (const auto& pair : m) {\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\n    }\n}\n\n/////////////// TESTES AUXILIARES /////////////\n\nvoid print_node(Node *node) {\n    if(node == nullptr) {\n        cout << \"Node(empty)\" << endl;\n    } else {\n        int parent_info = -1;\n        if(node->parent != nullptr) {\n            parent_info = node->parent->info;\n        }\n        cout << \"Node(\" << node->info << \", \"\n                        << parent_info << \", \"\n                        << node->size << \", \"\n                        << node->level << \", \"\n                        << node->height << \")\"\n                        << endl;\n    }\n}\n\nvoid print_tree(Node *current) {\n    if(current != nullptr) {\n        print_node(current);\n        print_tree(current->left);\n        print_tree(current->right);\n    }\n}\n\n/*\n Exemplo:\n \n    T =   32\n         /  \\\n        45  12\n       /  \\\n      10  37\n*/\n\n/////////////// TESTE FILL ///////////////\n\nvoid test_fill() {\n    cout << \"TESTE fill\" << endl;\n    BinaryTree tree;\n    Node *node32 = new Node(32);\n    Node *node45 = new Node(45);\n    Node *node10 = new Node(10);\n    Node *node37 = new Node(37);\n    Node *node12 = new Node(12);\n\n    cout << \"insert 32\" << endl; tree.root = node32;\n    cout << \"insert 45\" << endl; node32->left = node45;\n    cout << \"insert 37\" << endl; node45->right = node37;\n    cout << \"insert 10\" << endl; node45->left = node10;\n    cout << \"insert 12\" << endl; node32->right = node12;\n    tree.print();\n    \n    cout << \"fill\" << endl; tree.fill();\n\n    print_node(node32);\n    print_node(node45);\n    print_node(node10);\n    print_node(node37);\n    print_node(node12);\n}\n\n\n/////////////// TESTE FILL 2 ///////////////\n\nvoid test_fill_2() {\n    cout << \"TESTE fill 2\" << endl;\n    BinaryTree tree;\n    Node *root = new Node(32,\n        new Node(11,\n            new Node(6, NULL, NULL),\n            new Node(2, NULL, NULL)\n        ),\n        new Node(112,\n            new Node(63,\n                new Node(66, NULL, NULL),\n                new Node(11,\n                    new Node(-45, NULL, NULL),\n                    new Node(19,\n                        new Node(-1000, NULL, NULL),\n                        new Node(1223, NULL, NULL)\n                    )\n                )\n            ),\n            new Node(21, NULL, NULL)\n        )\n    );\n\n    tree.root = root;\n    tree.print();\n    \n    cout << \"fill\" << endl; tree.fill();\n\n    print_tree(tree.root);\n}\n\n\n/////////////// FIM TESTES ///////////////\n\nint main() {\n    std::string input;\n    std::cin >> input;\n\n    if(input == \"test_fill\") test_fill();\n    if(input == \"test_fill_2\") test_fill_2();\n}\n",
                "encoding": 0
            }
        ]
    }
}
