{
    "title": "@arvore: Construir \u00e1rvore binaria CPP",
    "description": "<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=yes\" />\n  <title>@arvore: Construir \u00e1rvore binaria CPP</title>\n  <style>\n    code{white-space: pre-wrap;}\n    span.smallcaps{font-variant: small-caps;}\n    div.columns{display: flex; gap: min(4vw, 1.5em);}\n    div.column{flex: auto; overflow-x: auto;}\n    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}\n    /* The extra [class] is a hack that increases specificity enough to\n       override a similar rule in reveal.js */\n    ul.task-list[class]{list-style: none;}\n    ul.task-list li input[type=\"checkbox\"] {\n      font-size: inherit;\n      width: 0.8em;\n      margin: 0 0.8em 0.2em -1.6em;\n      vertical-align: middle;\n    }\n    /* CSS for syntax highlighting */\n    html { -webkit-text-size-adjust: 100%; }\n    pre > code.sourceCode { white-space: pre; position: relative; }\n    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }\n    pre > code.sourceCode > span:empty { height: 1.2em; }\n    .sourceCode { overflow: visible; }\n    code.sourceCode > span { color: inherit; text-decoration: inherit; }\n    div.sourceCode { margin: 1em 0; }\n    pre.sourceCode { margin: 0; }\n    @media screen {\n    div.sourceCode { overflow: auto; }\n    }\n    @media print {\n    pre > code.sourceCode { white-space: pre-wrap; }\n    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }\n    }\n    pre.numberSource code\n      { counter-reset: source-line 0; }\n    pre.numberSource code > span\n      { position: relative; left: -4em; counter-increment: source-line; }\n    pre.numberSource code > span > a:first-child::before\n      { content: counter(source-line);\n        position: relative; left: -1em; text-align: right; vertical-align: baseline;\n        border: none; display: inline-block;\n        -webkit-touch-callout: none; -webkit-user-select: none;\n        -khtml-user-select: none; -moz-user-select: none;\n        -ms-user-select: none; user-select: none;\n        padding: 0 4px; width: 4em;\n        color: #aaaaaa;\n      }\n    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\n    div.sourceCode\n      {   }\n    @media screen {\n    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }\n    }\n    code span.al { color: #ff0000; font-weight: bold; } /* Alert */\n    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */\n    code span.at { color: #7d9029; } /* Attribute */\n    code span.bn { color: #40a070; } /* BaseN */\n    code span.bu { color: #008000; } /* BuiltIn */\n    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */\n    code span.ch { color: #4070a0; } /* Char */\n    code span.cn { color: #880000; } /* Constant */\n    code span.co { color: #60a0b0; font-style: italic; } /* Comment */\n    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */\n    code span.do { color: #ba2121; font-style: italic; } /* Documentation */\n    code span.dt { color: #902000; } /* DataType */\n    code span.dv { color: #40a070; } /* DecVal */\n    code span.er { color: #ff0000; font-weight: bold; } /* Error */\n    code span.ex { } /* Extension */\n    code span.fl { color: #40a070; } /* Float */\n    code span.fu { color: #06287e; } /* Function */\n    code span.im { color: #008000; font-weight: bold; } /* Import */\n    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */\n    code span.kw { color: #007020; font-weight: bold; } /* Keyword */\n    code span.op { color: #666666; } /* Operator */\n    code span.ot { color: #007020; } /* Other */\n    code span.pp { color: #bc7a00; } /* Preprocessor */\n    code span.sc { color: #4070a0; } /* SpecialChar */\n    code span.ss { color: #bb6688; } /* SpecialString */\n    code span.st { color: #4070a0; } /* String */\n    code span.va { color: #19177c; } /* Variable */\n    code span.vs { color: #4070a0; } /* VerbatimString */\n    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */\n  </style>\n</head>\n<body>\n<h1 id=\"construir-\u00e1rvore-binaria-cpp\">Construir \u00e1rvore binaria CPP</h1>\n<!-- toch -->\n<table>\n<thead>\n<tr class=\"header\">\n<th><a href=\"#intro\">Intro</a></th>\n<th><a href=\"#draft\">Draft</a></th>\n<th><a href=\"#tests\">Tests</a></th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>\n<!-- toch -->\n<h2 id=\"intro\">Intro</h2>\n<p>Neste exerc\u00edcio, voc\u00ea implementar\u00e1 uma <strong>\u00c1rvore\nBin\u00e1ria</strong>, uma estrutura de dados hier\u00e1rquica amplamente usada em\ncomputa\u00e7\u00e3o. Cada elemento da \u00e1rvore \u00e9 armazenado em um n\u00f3, que pode ter\nno m\u00e1ximo dois filhos: o filho esquerdo e o filho direito. Essa\nestrutura permite organizar e buscar dados de maneira eficiente, sendo\nmuito utilizada em diversas aplica\u00e7\u00f5es, como sistemas de arquivos,\n\u00e1rvores de decis\u00e3o e algoritmos de busca.</p>\n<p>Por simplicidade, as informa\u00e7\u00f5es da \u00e1rvore ser\u00e3o representadas como\ninteiros.</p>\n<p>No arquivo <code>lib.cpp</code>, encontra-se a classe\n<code>BinaryTree</code>, que possui os seguintes m\u00e9todos:</p>\n<ul>\n<li><del><code>BinaryTree()</code></del></li>\n<li><del><code>~BinaryTree()</code></del></li>\n<li><code>Node* search(int info)</code></li>\n<li><code>void insert(Node *current, int info)</code></li>\n<li><code>int size()</code></li>\n<li><code>int min()</code></li>\n<li><code>int max()</code></li>\n<li><del><code>void clear()</code></del></li>\n<li><del><code>bool empty()</code></del></li>\n<li><del><code>void print()</code></del></li>\n</ul>\n<p>Os m\u00e9todos riscados j\u00e1 est\u00e3o implementados. Voc\u00ea precisar\u00e1\nimplementar os demais. A funcionalidade de cada m\u00e9todo est\u00e1 descrita em\ncoment\u00e1rios no pr\u00f3prio arquivo <code>lib.cpp</code>. Sua tarefa \u00e9\ncompletar o arquivo, implementando as funcionalidades faltantes.</p>\n<h3 id=\"observa\u00e7\u00f5es\">Observa\u00e7\u00f5es</h3>\n<ul>\n<li><p><strong>OBS. 1:</strong> N\u00e3o altere os m\u00e9todos j\u00e1\nimplementados.</p></li>\n<li><p><strong>OBS. 2:</strong> N\u00e3o \u00e9 necess\u00e1rio escrever a fun\u00e7\u00e3o\n<code>main()</code>. Ela j\u00e1 est\u00e1 implementada internamente no sistema de\navalia\u00e7\u00e3o.</p></li>\n</ul>\n<h2 id=\"draft\">Draft</h2>\n<ul>\n<li>Voc\u00ea deve implementar os m\u00e9todos faltantes no arquivo\n<code>lib.cpp</code>.</li>\n</ul>\n<!-- links .cache/draft -->\n<ul>\n<li>cpp\n<ul>\n<li><a\nhref=\"https://github.com/qxcodeed/arcade/blob/master/base/arvore/.cache/draft/cpp/lib.cpp\">lib.cpp</a></li>\n<li><a\nhref=\"https://github.com/qxcodeed/arcade/blob/master/base/arvore/.cache/draft/cpp/main.cpp\">main.cpp</a>\n<!-- links --></li>\n</ul></li>\n</ul>\n<h2 id=\"tests\">Tests</h2>\n<h3 id=\"entrada\">Entrada</h3>\n<ul>\n<li>Voc\u00ea receber\u00e1 um conjunto de opera\u00e7\u00f5es que devem ser realizadas na\n\u00e1rvore bin\u00e1ria, incluindo inser\u00e7\u00f5es, buscas e c\u00e1lculos de tamanho,\nm\u00ednimo e m\u00e1ximo.</li>\n</ul>\n<h3 id=\"sa\u00edda\">Sa\u00edda</h3>\n<ul>\n<li>Seu programa deve imprimir os resultados das opera\u00e7\u00f5es realizadas na\n\u00e1rvore. O formato de sa\u00edda ser\u00e1 especificado nos casos de teste.</li>\n</ul>\n<div class=\"sourceCode\" id=\"cb1\"><pre\nclass=\"sourceCode txt\"><code class=\"sourceCode default\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>Inserir 10</span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>Inserir 5</span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>Inserir 15</span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>Buscar 10</span>\n<span id=\"cb1-6\"><a href=\"#cb1-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>Tamanho</span>\n<span id=\"cb1-7\"><a href=\"#cb1-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>Minimo</span>\n<span id=\"cb1-8\"><a href=\"#cb1-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>Maximo</span>\n<span id=\"cb1-9\"><a href=\"#cb1-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>========</span>\n<span id=\"cb1-10\"><a href=\"#cb1-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>Encontrado: 10</span>\n<span id=\"cb1-11\"><a href=\"#cb1-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>Tamanho: 3</span>\n<span id=\"cb1-12\"><a href=\"#cb1-12\" aria-hidden=\"true\" tabindex=\"-1\"></a>Minimo: 5</span>\n<span id=\"cb1-13\"><a href=\"#cb1-13\" aria-hidden=\"true\" tabindex=\"-1\"></a>Maximo: 15</span>\n<span id=\"cb1-14\"><a href=\"#cb1-14\" aria-hidden=\"true\" tabindex=\"-1\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></code></pre></div>\n</body>\n</html>",
    "upload": [
        {
            "name": "vpl_evaluate.cases",
            "contents": ">>>>>>>> INSERT\nInserir 10\nInserir 5\nInserir 15\nBuscar 10\nTamanho\nMinimo\nMaximo\n======== EXPECT\nEncontrado: 10\nTamanho: 3\nMinimo: 5\nMaximo: 15\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_insert\ntest_insert\n======== EXPECT\nTESTE insert\ninsert 32\ninsert 45\ninsert 12\ninsert 10\ninsert 37\nBinaryTree: Node-32{(Node-45{(Node-10{(, )}, Node-37{(, )})}, Node-12{(, )})}\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_search\ntest_search\n======== EXPECT\nTESTE search\nBinaryTree: Node-55{(Node-12{(Node-76{(Node-33{(, )}, )}, Node-4{(, )})}, Node-110{(Node-762{(Node-77{(, )}, Node--20{(, Node-19{(, )})})}, Node-1267{(Node--665{(, )}, Node--221{(, Node-9{(, )})})})})}\nsearch 55: Node(55)\nsearch 9: Node(9)\nsearch 77: Node(77)\nsearch -665: Node(-665)\nsearch 110: Node(110)\nsearch -29: Node(empty)\nsearch 1000: Node(empty)\nsearch 45: Node(empty)\nsearch 25: Node(empty)\nsearch 35: Node(empty)\nsearch 65: Node(empty)\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_size\ntest_size\n======== EXPECT\nTESTE size\ninsert 32\nsize 1\ninsert 45\nsize 2\ninsert 12\nsize 3\ninsert 10\nsize 3\ninsert 37\nBinaryTree: Node-32{(Node-45{(, )}, Node-12{(, )})}\nsize 3\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_min_max\ntest_min_max\n======== EXPECT\nTESTE min max\nmin -1\nmax -1\ninsert 32\ninsert 45\ninsert 12\ninsert 10\ninsert 37\nBinaryTree: Node-32{(Node-45{(Node-10{(, )}, Node-37{(, )})}, Node-12{(, )})}\nmin 10\nmax 45\n<<<<<<<< FINISH\n\n",
            "encoding": 0
        }
    ],
    "keep": [],
    "required": [],
    "draft": {
        "cpp": [
            {
                "name": "lib.cpp",
                "contents": "#include <iostream>\n\n// Node: classe utilizada para representar um No\n// Nao altere essa classe\nstruct Node {\n    int info; // Informacao salva pelo usuario na arvore\n    Node *left; // Ponteiro para o No filho a esquerda\n    Node *right; // Ponteiro para o No filho a direita\n\n    // Construtores\n    Node(); \n    Node(int info, Node *left=nullptr, Node *right=nullptr);\n    \n    // Destrutor\n    ~Node();\n};\n\n// Binary Search Tree ou\n// Arvore de busca binaria\n// Altere somente os campos marcados com TODO\nstruct BinaryTree {\n    Node *root;   // Ponteiro para o No raiz da arvore\n\n    BinaryTree() {\n        root = nullptr;\n    }\n\n    ~BinaryTree() { // Destrutor\n        clear();\n    }\n\n    // Retorna o No da arvore que possui sua informacao igual a 'info',\n    // ou retorna um No vazio (NULL) caso a arvore nao possua tal 'info'.\n    Node* search(int info) {\n        // TODO: Complexidade O(n)\n        (void) info;\n        return nullptr;\n    }\n\n\n    // Cria um novo No com a informacao 'info' e o adiciona\n    // a esquerda do No 'current'.\n    // Pode assumir que o No esquerdo de 'current' esta vazio.\n    void insert_left(Node *current, int info) {\n        // TODO: Complexidade O(1)\n        (void) info;\n        (void) current;\n    }\n    /*\n        Exemplo:\n\n           T =   12\n                /  \\\n               50  34\n                 \\   \\\n                  3   10\n                T.insert_left(No[50], 6)\n\n           T =   12\n                /  \\\n               50  34\n              /  \\   \\\n             6    3  10\n    */\n\n    \n    // Cria um novo No com a informacao 'info' e o adiciona\n    // a direita do No 'current'.\n    // Pode assumir que o No direito de 'current' esta vazio.\n    void insert_right(Node *current, int info) {\n        // TODO: Complexidade O(1)\n        (void) info;\n        (void) current;\n    }\n    /*\n        Exemplo:\n\n           T =   12\n                /  \\\n               50  34\n                 \\   \n                  3   \n    \n        T.insert_right(No[34], 10)\n\n           T =   12\n                /  \\\n               50  34\n                 \\   \\\n                  3  10\n    */\n\n\n    // Retorna a quantidade de elementos da arvore.\n    int size() {\n        // TODO: Complexidade O(n)\n        return 0;\n    }\n\n    int _size(Node *current) {\n        if(current == nullptr) return 0;\n        return _size(current->left) + _size(current->right) + 1;\n    }\n\n\n    // Retorna o menor elemento da arvore, ou -1 caso nao exista\n    int min() {\n        // TODO: Complexidade O(n)\n        return -1;\n    }\n\n\n    // Retorna o maior elemento da arvore, ou -1 caso nao exista\n    int max() {\n        // TODO: Complexidade O(n)\n        return -1;\n    }\n\n\n    // Deixa a lista vazia, com zero elementos\n    void clear() {\n        _clear(root);\n        root = NULL;\n    }\n\n    void _clear(Node* current) {\n        if(current == NULL) return;\n        _clear(current->left);\n        _clear(current->right);\n        delete current;\n    }\n\n    // Devolve true se vazia e false caso contrario\n    bool empty() {\n        return root == NULL;\n    }\n\n    // Printa as informacoes da lista\n    void print() {\n        std::cout << \"BinaryTree: \";\n        _print(root);\n        std::cout << std::endl;\n    }\n\n    void _print(Node *current) {\n        if(current != NULL){\n            std::cout << \"Node-\" << current->info << \"{(\";\n            _print(current->left);\n            std::cout << \", \";\n            _print(current->right);\n            std::cout << \")}\";\n        }\n    }\n};\n",
                "encoding": 0
            },
            {
                "name": "main.cpp",
                "contents": "#include <iostream>\n#include <map>\n#include \"lib.cpp\"\n\nusing std::cout;\nusing std::endl;\n\nbool LOG_ALLOCATED = false;\nstd::map<void*, int> allocated_nodes_status = {};\nstd::map<int, int> mapa = {};\nconst int ALLOCATED = 1;\nconst int DELETED = 2;\n\n// Salvar Nos alocados\nNode::Node() {\n    allocated_nodes_status[this] = ALLOCATED;\n}\n\nNode::Node(int info, Node* left, Node* right) {\n    allocated_nodes_status[this] = ALLOCATED;\n    this->info = info;\n    this->left = left;\n    this->right = right;\n}\nNode::~Node() {\n    allocated_nodes_status[this] = DELETED;\n}\n\ntemplate <typename K, typename V>\nvoid printMap(const std::map<K, V>& m) {\n    for (const auto& pair : m) {\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\n    }\n}\n\n/////////////// TESTES AUXILIARES /////////////\n\nvoid print_node(Node *node) {\n    if(node == NULL){\n        cout << \"Node(empty)\" << endl;\n    }else{\n        cout << \"Node(\" << node->info << \")\" << endl;\n    }\n}\n/*\n// Exemplo:\n// \n//    T =   32\n//         /  \\\n//        45  12\n//       /  \\\n//      10  37\n*/\n\n/////////////// TESTE SEARCH ///////////////\n\nvoid test_insert() {\n    cout << \"TESTE insert\" << endl;\n    BinaryTree tree;\n    Node *node32 = new Node(32);\n\n    cout << \"insert 32\" << endl; tree.root = node32;\n    cout << \"insert 45\" << endl; tree.insert_left(node32, 45);\n    cout << \"insert 12\" << endl; tree.insert_right(node32, 12);\n    cout << \"insert 10\" << endl; tree.insert_left(node32->left, 10);\n    cout << \"insert 37\" << endl; tree.insert_right(node32->left, 37);\n    tree.print();\n}\n\n\n/////////////// TESTE SEARCH ///////////////\n/*\n// Exemplo:\n// \n//    T =   40\n//         /  \\\n//        20  70\n//       /  \\\n//      10  30\n*/\n\nvoid test_search() {\n    cout << \"TESTE search\" << endl;\n    BinaryTree tree;\n\n    tree.root = new Node(55,\n        new Node(12,\n            new Node(76,\n                new Node(33, NULL, NULL)\n            )\n            ,\n            new Node(4, NULL, NULL)\n        )\n        ,\n        new Node(110,\n            new Node(762,\n                new Node(77, NULL, NULL),\n                new Node(-20, NULL, new Node(19, NULL, NULL))\n            )\n            ,\n            new Node(1267,\n                new Node(-665, NULL, NULL),\n                new Node(-221, NULL, new Node(9, NULL, NULL))\n            )\n        )\n    );\n\n    tree.print();\n    \n    cout << \"search 55: \"; print_node(tree.search(55));\n    cout << \"search 9: \"; print_node(tree.search(9));\n    cout << \"search 77: \"; print_node(tree.search(77));\n    cout << \"search -665: \"; print_node(tree.search(-665));\n    cout << \"search 110: \"; print_node(tree.search(110));\n\n    cout << \"search -29: \"; print_node(tree.search(-29));\n    cout << \"search 1000: \"; print_node(tree.search(1000));\n    cout << \"search 45: \"; print_node(tree.search(44));\n    cout << \"search 25: \"; print_node(tree.search(25));\n    cout << \"search 35: \"; print_node(tree.search(35));\n    cout << \"search 65: \"; print_node(tree.search(65));\n}\n\n/////////////// TESTE SIZE ///////////////\n\nvoid test_size() {\n    cout << \"TESTE size\" << endl;\n    BinaryTree tree;\n    Node *node32 = new Node(32);\n    \n    Node *node45 = new Node(45);\n\n    cout << \"insert 32\" << endl; tree.root = node32;\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 45\" << endl; tree.insert_left(node32, 45);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 12\" << endl; tree.insert_right(node32, 12);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 10\" << endl; tree.insert_left(node45, 10);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 37\" << endl; tree.insert_right(node45, 37);\n    tree.print();\n    cout << \"size \" << tree.size() << endl;\n}\n\n/////////////// TESTE MIN MAX ///////////////\n\nvoid test_min_max() {\n    cout << \"TESTE min max\" << endl;\n    BinaryTree tree;\n    Node *node32 = new Node(32);\n\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 32\" << endl; tree.root = node32;\n    cout << \"insert 45\" << endl; tree.insert_left(node32, 45);\n    cout << \"insert 12\" << endl; tree.insert_right(node32, 12);\n    cout << \"insert 10\" << endl; tree.insert_left(node32->left, 10);\n    cout << \"insert 37\" << endl; tree.insert_right(node32->left, 37);\n    tree.print();\n\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n}\n\n/////////////// FIM TESTES ///////////////\n\nint main() {\n    std::string input;\n    std::cin >> input;\n\n    if(input == \"test_insert\") test_insert();\n    if(input == \"test_search\") test_search();\n    if(input == \"test_size\") test_size();\n    if(input == \"test_min_max\") test_min_max();\n}\n",
                "encoding": 0
            }
        ]
    }
}
