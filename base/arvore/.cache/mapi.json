{
    "title": "@arvore: Construir \u00e1rvore binaria CPP",
    "description": "# Construir \u00e1rvore binaria CPP\n\n<!-- toch -->\n[Intro](#intro) | [Draft](#draft) | [Tests](#tests)\n-- | -- | --\n<!-- toch -->\n\n## Intro\n\nNeste exerc\u00edcio, voc\u00ea implementar\u00e1 uma **\u00c1rvore Bin\u00e1ria**, uma estrutura de dados hier\u00e1rquica amplamente usada em computa\u00e7\u00e3o. Cada elemento da \u00e1rvore \u00e9 armazenado em um n\u00f3, que pode ter no m\u00e1ximo dois filhos: o filho esquerdo e o filho direito. Essa estrutura permite organizar e buscar dados de maneira eficiente, sendo muito utilizada em diversas aplica\u00e7\u00f5es, como sistemas de arquivos, \u00e1rvores de decis\u00e3o e algoritmos de busca.\n\nPor simplicidade, as informa\u00e7\u00f5es da \u00e1rvore ser\u00e3o representadas como inteiros.\n\nNo arquivo `lib.cpp`, encontra-se a classe `BinaryTree`, que possui os seguintes m\u00e9todos:\n\n- ~~`BinaryTree()`~~\n- ~~`~BinaryTree()`~~\n- `Node* search(int info)`\n- `void insert(Node *current, int info)`\n- `int size()`\n- `int min()`\n- `int max()`\n- ~~`void clear()`~~\n- ~~`bool empty()`~~\n- ~~`void print()`~~\n\nOs m\u00e9todos riscados j\u00e1 est\u00e3o implementados. Voc\u00ea precisar\u00e1 implementar os demais. A funcionalidade de cada m\u00e9todo est\u00e1 descrita em coment\u00e1rios no pr\u00f3prio arquivo `lib.cpp`. Sua tarefa \u00e9 completar o arquivo, implementando as funcionalidades faltantes.\n\n### Observa\u00e7\u00f5es\n\n- **OBS. 1:** N\u00e3o altere os m\u00e9todos j\u00e1 implementados.\n\n- **OBS. 2:** N\u00e3o \u00e9 necess\u00e1rio escrever a fun\u00e7\u00e3o `main()`. Ela j\u00e1 est\u00e1 implementada internamente no sistema de avalia\u00e7\u00e3o.\n\n## Draft\n\n- Voc\u00ea deve implementar os m\u00e9todos faltantes no arquivo `lib.cpp`.\n\n<!-- links .cache/draft -->\n- cpp\n  - [lib.cpp](https://github.com/qxcodeed/arcade/blob/master/base/arvore/.cache/draft/cpp/lib.cpp)\n  - [main.cpp](https://github.com/qxcodeed/arcade/blob/master/base/arvore/.cache/draft/cpp/main.cpp)\n<!-- links -->\n\n## Tests\n\n### Entrada\n\n- Voc\u00ea receber\u00e1 um conjunto de opera\u00e7\u00f5es que devem ser realizadas na \u00e1rvore bin\u00e1ria, incluindo inser\u00e7\u00f5es, buscas e c\u00e1lculos de tamanho, m\u00ednimo e m\u00e1ximo.\n\n### Sa\u00edda\n\n- Seu programa deve imprimir os resultados das opera\u00e7\u00f5es realizadas na \u00e1rvore. O formato de sa\u00edda ser\u00e1 especificado nos casos de teste.\n\n```txt\n>>>>>>>>\nInserir 10\nInserir 5\nInserir 15\nBuscar 10\nTamanho\nMinimo\nMaximo\n========\nEncontrado: 10\nTamanho: 3\nMinimo: 5\nMaximo: 15\n<<<<<<<<\n```\n",
    "upload": [
        {
            "name": "vpl_evaluate.cases",
            "contents": ">>>>>>>> INSERT\nInserir 10\nInserir 5\nInserir 15\nBuscar 10\nTamanho\nMinimo\nMaximo\n======== EXPECT\nEncontrado: 10\nTamanho: 3\nMinimo: 5\nMaximo: 15\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_insert\ntest_insert\n======== EXPECT\nTESTE insert\ninsert 32\ninsert 45\ninsert 12\ninsert 10\ninsert 37\nBinaryTree: Node-32{(Node-45{(Node-10{(, )}, Node-37{(, )})}, Node-12{(, )})}\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_search\ntest_search\n======== EXPECT\nTESTE search\nBinaryTree: Node-55{(Node-12{(Node-76{(Node-33{(, )}, )}, Node-4{(, )})}, Node-110{(Node-762{(Node-77{(, )}, Node--20{(, Node-19{(, )})})}, Node-1267{(Node--665{(, )}, Node--221{(, Node-9{(, )})})})})}\nsearch 55: Node(55)\nsearch 9: Node(9)\nsearch 77: Node(77)\nsearch -665: Node(-665)\nsearch 110: Node(110)\nsearch -29: Node(empty)\nsearch 1000: Node(empty)\nsearch 45: Node(empty)\nsearch 25: Node(empty)\nsearch 35: Node(empty)\nsearch 65: Node(empty)\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_size\ntest_size\n======== EXPECT\nTESTE size\ninsert 32\nsize 1\ninsert 45\nsize 2\ninsert 12\nsize 3\ninsert 10\nsize 3\ninsert 37\nBinaryTree: Node-32{(Node-45{(, )}, Node-12{(, )})}\nsize 3\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_min_max\ntest_min_max\n======== EXPECT\nTESTE min max\nmin -1\nmax -1\ninsert 32\ninsert 45\ninsert 12\ninsert 10\ninsert 37\nBinaryTree: Node-32{(Node-45{(Node-10{(, )}, Node-37{(, )})}, Node-12{(, )})}\nmin 10\nmax 45\n<<<<<<<< FINISH\n\n",
            "type": "hide"
        }
    ],
    "draft": {
        "cpp": [
            {
                "name": "lib.cpp",
                "contents": "#include <iostream>\n\n// Node: classe utilizada para representar um No\n// Nao altere essa classe\nstruct Node {\n    int info; // Informacao salva pelo usuario na arvore\n    Node *left; // Ponteiro para o No filho a esquerda\n    Node *right; // Ponteiro para o No filho a direita\n\n    // Construtores\n    Node(); \n    Node(int info, Node *left=nullptr, Node *right=nullptr);\n    \n    // Destrutor\n    ~Node();\n};\n\n// Binary Search Tree ou\n// Arvore de busca binaria\n// Altere somente os campos marcados com TODO\nstruct BinaryTree {\n    Node *root;   // Ponteiro para o No raiz da arvore\n\n    BinaryTree() {\n        root = nullptr;\n    }\n\n    ~BinaryTree() { // Destrutor\n        clear();\n    }\n\n    // Retorna o No da arvore que possui sua informacao igual a 'info',\n    // ou retorna um No vazio (NULL) caso a arvore nao possua tal 'info'.\n    Node* search(int info) {\n        // TODO: Complexidade O(n)\n        (void) info;\n        return nullptr;\n    }\n\n\n    // Cria um novo No com a informacao 'info' e o adiciona\n    // a esquerda do No 'current'.\n    // Pode assumir que o No esquerdo de 'current' esta vazio.\n    void insert_left(Node *current, int info) {\n        // TODO: Complexidade O(1)\n        (void) info;\n        (void) current;\n    }\n    /*\n        Exemplo:\n\n           T =   12\n                /  \\\n               50  34\n                 \\   \\\n                  3   10\n                T.insert_left(No[50], 6)\n\n           T =   12\n                /  \\\n               50  34\n              /  \\   \\\n             6    3  10\n    */\n\n    \n    // Cria um novo No com a informacao 'info' e o adiciona\n    // a direita do No 'current'.\n    // Pode assumir que o No direito de 'current' esta vazio.\n    void insert_right(Node *current, int info) {\n        // TODO: Complexidade O(1)\n        (void) info;\n        (void) current;\n    }\n    /*\n        Exemplo:\n\n           T =   12\n                /  \\\n               50  34\n                 \\   \n                  3   \n    \n        T.insert_right(No[34], 10)\n\n           T =   12\n                /  \\\n               50  34\n                 \\   \\\n                  3  10\n    */\n\n\n    // Retorna a quantidade de elementos da arvore.\n    int size() {\n        // TODO: Complexidade O(n)\n        return 0;\n    }\n\n    int _size(Node *current) {\n        if(current == nullptr) return 0;\n        return _size(current->left) + _size(current->right) + 1;\n    }\n\n\n    // Retorna o menor elemento da arvore, ou -1 caso nao exista\n    int min() {\n        // TODO: Complexidade O(n)\n        return -1;\n    }\n\n\n    // Retorna o maior elemento da arvore, ou -1 caso nao exista\n    int max() {\n        // TODO: Complexidade O(n)\n        return -1;\n    }\n\n\n    // Deixa a lista vazia, com zero elementos\n    void clear() {\n        _clear(root);\n        root = NULL;\n    }\n\n    void _clear(Node* current) {\n        if(current == NULL) return;\n        _clear(current->left);\n        _clear(current->right);\n        delete current;\n    }\n\n    // Devolve true se vazia e false caso contrario\n    bool empty() {\n        return root == NULL;\n    }\n\n    // Printa as informacoes da lista\n    void print() {\n        std::cout << \"BinaryTree: \";\n        _print(root);\n        std::cout << std::endl;\n    }\n\n    void _print(Node *current) {\n        if(current != NULL){\n            std::cout << \"Node-\" << current->info << \"{(\";\n            _print(current->left);\n            std::cout << \", \";\n            _print(current->right);\n            std::cout << \")}\";\n        }\n    }\n};\n",
                "type": "show"
            },
            {
                "name": "main.cpp",
                "contents": "#include <iostream>\n#include <map>\n#include \"lib.cpp\"\n\nusing std::cout;\nusing std::endl;\n\nbool LOG_ALLOCATED = false;\nstd::map<void*, int> allocated_nodes_status = {};\nstd::map<int, int> mapa = {};\nconst int ALLOCATED = 1;\nconst int DELETED = 2;\n\n// Salvar Nos alocados\nNode::Node() {\n    allocated_nodes_status[this] = ALLOCATED;\n}\n\nNode::Node(int info, Node* left, Node* right) {\n    allocated_nodes_status[this] = ALLOCATED;\n    this->info = info;\n    this->left = left;\n    this->right = right;\n}\nNode::~Node() {\n    allocated_nodes_status[this] = DELETED;\n}\n\ntemplate <typename K, typename V>\nvoid printMap(const std::map<K, V>& m) {\n    for (const auto& pair : m) {\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\n    }\n}\n\n/////////////// TESTES AUXILIARES /////////////\n\nvoid print_node(Node *node) {\n    if(node == NULL){\n        cout << \"Node(empty)\" << endl;\n    }else{\n        cout << \"Node(\" << node->info << \")\" << endl;\n    }\n}\n/*\n// Exemplo:\n// \n//    T =   32\n//         /  \\\n//        45  12\n//       /  \\\n//      10  37\n*/\n\n/////////////// TESTE SEARCH ///////////////\n\nvoid test_insert() {\n    cout << \"TESTE insert\" << endl;\n    BinaryTree tree;\n    Node *node32 = new Node(32);\n\n    cout << \"insert 32\" << endl; tree.root = node32;\n    cout << \"insert 45\" << endl; tree.insert_left(node32, 45);\n    cout << \"insert 12\" << endl; tree.insert_right(node32, 12);\n    cout << \"insert 10\" << endl; tree.insert_left(node32->left, 10);\n    cout << \"insert 37\" << endl; tree.insert_right(node32->left, 37);\n    tree.print();\n}\n\n\n/////////////// TESTE SEARCH ///////////////\n/*\n// Exemplo:\n// \n//    T =   40\n//         /  \\\n//        20  70\n//       /  \\\n//      10  30\n*/\n\nvoid test_search() {\n    cout << \"TESTE search\" << endl;\n    BinaryTree tree;\n\n    tree.root = new Node(55,\n        new Node(12,\n            new Node(76,\n                new Node(33, NULL, NULL)\n            )\n            ,\n            new Node(4, NULL, NULL)\n        )\n        ,\n        new Node(110,\n            new Node(762,\n                new Node(77, NULL, NULL),\n                new Node(-20, NULL, new Node(19, NULL, NULL))\n            )\n            ,\n            new Node(1267,\n                new Node(-665, NULL, NULL),\n                new Node(-221, NULL, new Node(9, NULL, NULL))\n            )\n        )\n    );\n\n    tree.print();\n    \n    cout << \"search 55: \"; print_node(tree.search(55));\n    cout << \"search 9: \"; print_node(tree.search(9));\n    cout << \"search 77: \"; print_node(tree.search(77));\n    cout << \"search -665: \"; print_node(tree.search(-665));\n    cout << \"search 110: \"; print_node(tree.search(110));\n\n    cout << \"search -29: \"; print_node(tree.search(-29));\n    cout << \"search 1000: \"; print_node(tree.search(1000));\n    cout << \"search 45: \"; print_node(tree.search(44));\n    cout << \"search 25: \"; print_node(tree.search(25));\n    cout << \"search 35: \"; print_node(tree.search(35));\n    cout << \"search 65: \"; print_node(tree.search(65));\n}\n\n/////////////// TESTE SIZE ///////////////\n\nvoid test_size() {\n    cout << \"TESTE size\" << endl;\n    BinaryTree tree;\n    Node *node32 = new Node(32);\n    \n    Node *node45 = new Node(45);\n\n    cout << \"insert 32\" << endl; tree.root = node32;\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 45\" << endl; tree.insert_left(node32, 45);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 12\" << endl; tree.insert_right(node32, 12);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 10\" << endl; tree.insert_left(node45, 10);\n    cout << \"size \" << tree.size() << endl;\n    cout << \"insert 37\" << endl; tree.insert_right(node45, 37);\n    tree.print();\n    cout << \"size \" << tree.size() << endl;\n}\n\n/////////////// TESTE MIN MAX ///////////////\n\nvoid test_min_max() {\n    cout << \"TESTE min max\" << endl;\n    BinaryTree tree;\n    Node *node32 = new Node(32);\n\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n    cout << \"insert 32\" << endl; tree.root = node32;\n    cout << \"insert 45\" << endl; tree.insert_left(node32, 45);\n    cout << \"insert 12\" << endl; tree.insert_right(node32, 12);\n    cout << \"insert 10\" << endl; tree.insert_left(node32->left, 10);\n    cout << \"insert 37\" << endl; tree.insert_right(node32->left, 37);\n    tree.print();\n\n    cout << \"min \" << tree.min() << endl; cout << \"max \" << tree.max() << endl;\n}\n\n/////////////// FIM TESTES ///////////////\n\nint main() {\n    std::string input;\n    std::cin >> input;\n\n    if(input == \"test_insert\") test_insert();\n    if(input == \"test_search\") test_search();\n    if(input == \"test_size\") test_size();\n    if(input == \"test_min_max\") test_min_max();\n}\n",
                "type": "show"
            }
        ]
    }
}
