{
    "title": "@incompleta: Arvore incompleta",
    "description": "<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=yes\" />\n  <title>@incompleta: Arvore incompleta</title>\n  <style>\n    code{white-space: pre-wrap;}\n    span.smallcaps{font-variant: small-caps;}\n    div.columns{display: flex; gap: min(4vw, 1.5em);}\n    div.column{flex: auto; overflow-x: auto;}\n    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}\n    /* The extra [class] is a hack that increases specificity enough to\n       override a similar rule in reveal.js */\n    ul.task-list[class]{list-style: none;}\n    ul.task-list li input[type=\"checkbox\"] {\n      font-size: inherit;\n      width: 0.8em;\n      margin: 0 0.8em 0.2em -1.6em;\n      vertical-align: middle;\n    }\n    /* CSS for syntax highlighting */\n    html { -webkit-text-size-adjust: 100%; }\n    pre > code.sourceCode { white-space: pre; position: relative; }\n    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }\n    pre > code.sourceCode > span:empty { height: 1.2em; }\n    .sourceCode { overflow: visible; }\n    code.sourceCode > span { color: inherit; text-decoration: inherit; }\n    div.sourceCode { margin: 1em 0; }\n    pre.sourceCode { margin: 0; }\n    @media screen {\n    div.sourceCode { overflow: auto; }\n    }\n    @media print {\n    pre > code.sourceCode { white-space: pre-wrap; }\n    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }\n    }\n    pre.numberSource code\n      { counter-reset: source-line 0; }\n    pre.numberSource code > span\n      { position: relative; left: -4em; counter-increment: source-line; }\n    pre.numberSource code > span > a:first-child::before\n      { content: counter(source-line);\n        position: relative; left: -1em; text-align: right; vertical-align: baseline;\n        border: none; display: inline-block;\n        -webkit-touch-callout: none; -webkit-user-select: none;\n        -khtml-user-select: none; -moz-user-select: none;\n        -ms-user-select: none; user-select: none;\n        padding: 0 4px; width: 4em;\n        color: #aaaaaa;\n      }\n    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\n    div.sourceCode\n      {   }\n    @media screen {\n    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }\n    }\n    code span.al { color: #ff0000; font-weight: bold; } /* Alert */\n    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */\n    code span.at { color: #7d9029; } /* Attribute */\n    code span.bn { color: #40a070; } /* BaseN */\n    code span.bu { color: #008000; } /* BuiltIn */\n    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */\n    code span.ch { color: #4070a0; } /* Char */\n    code span.cn { color: #880000; } /* Constant */\n    code span.co { color: #60a0b0; font-style: italic; } /* Comment */\n    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */\n    code span.do { color: #ba2121; font-style: italic; } /* Documentation */\n    code span.dt { color: #902000; } /* DataType */\n    code span.dv { color: #40a070; } /* DecVal */\n    code span.er { color: #ff0000; font-weight: bold; } /* Error */\n    code span.ex { } /* Extension */\n    code span.fl { color: #40a070; } /* Float */\n    code span.fu { color: #06287e; } /* Function */\n    code span.im { color: #008000; font-weight: bold; } /* Import */\n    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */\n    code span.kw { color: #007020; font-weight: bold; } /* Keyword */\n    code span.op { color: #666666; } /* Operator */\n    code span.ot { color: #007020; } /* Other */\n    code span.pp { color: #bc7a00; } /* Preprocessor */\n    code span.sc { color: #4070a0; } /* SpecialChar */\n    code span.ss { color: #bb6688; } /* SpecialString */\n    code span.st { color: #4070a0; } /* String */\n    code span.va { color: #19177c; } /* Variable */\n    code span.vs { color: #4070a0; } /* VerbatimString */\n    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */\n  </style>\n</head>\n<body>\n<h1 id=\"arvore-incompleta\">Arvore incompleta</h1>\n<!-- toch -->\n<table>\n<thead>\n<tr class=\"header\">\n<th><a href=\"#intro\">Intro</a></th>\n<th><a href=\"#draft\">Draft</a></th>\n<th><a href=\"#tests\">Tests</a></th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>\n<!-- toch -->\n<h2 id=\"intro\">Intro</h2>\n<p>Neste exerc\u00edcio, voc\u00ea ir\u00e1 treinar a atribui\u00e7\u00e3o de valores\nrelacionados a cada n\u00f3 de uma \u00e1rvore bin\u00e1ria. A \u00e1rvore \u00e9 composta por\nn\u00f3s, onde cada n\u00f3 pode ter um filho \u00e0 esquerda e um filho \u00e0 direita.\nAl\u00e9m disso, cada n\u00f3 possui os seguintes atributos adicionais:</p>\n<ul>\n<li><code>Node *parent</code>: um ponteiro para o n\u00f3 pai.</li>\n<li><code>int size</code>: o tamanho da sub\u00e1rvore enraizada nesse\nn\u00f3.</li>\n<li><code>int level</code>: o n\u00edvel do n\u00f3 na \u00e1rvore (come\u00e7ando em 0 para\na raiz).</li>\n<li><code>int height</code>: a altura da sub\u00e1rvore enraizada nesse\nn\u00f3.</li>\n</ul>\n<p>A \u00e1rvore \u00e9 iniciada sem esses valores atribu\u00eddos, e sua tarefa \u00e9\nimplementar o m\u00e9todo <code>fill()</code> para preencher corretamente\nessas informa\u00e7\u00f5es. Este m\u00e9todo deve ser capaz de percorrer a \u00e1rvore e\ncalcular os valores de cada n\u00f3 de maneira recursiva.</p>\n<p><strong>Importante</strong>: N\u00e3o altere os m\u00e9todos j\u00e1 implementados\nno arquivo <code>lib.cpp</code>. Voc\u00ea deve se concentrar apenas em\nimplementar as funcionalidades que est\u00e3o faltando. O arquivo principal\n<code>main()</code> j\u00e1 est\u00e1 implementado, ent\u00e3o voc\u00ea n\u00e3o precisa se\npreocupar com isso.</p>\n<h2 id=\"draft\">Draft</h2>\n<ul>\n<li>Voc\u00ea deve implementar a fun\u00e7\u00e3o <code>fill()</code> no arquivo\n<code>lib.cpp</code> para que os atributos <code>parent</code>,\n<code>size</code>, <code>level</code> e <code>height</code> sejam\ncorretamente atribu\u00eddos a cada n\u00f3 da \u00e1rvore.</li>\n</ul>\n<!-- links .cache/draft -->\n<ul>\n<li>cpp\n<ul>\n<li><a\nhref=\"https://github.com/qxcodeed/arcade/blob/master/base/incompleta/.cache/draft/cpp/lib.cpp\">lib.cpp</a></li>\n<li><a\nhref=\"https://github.com/qxcodeed/arcade/blob/master/base/incompleta/.cache/draft/cpp/main.cpp\">main.cpp</a>\n<!-- links --></li>\n</ul></li>\n</ul>\n<h2 id=\"tests\">Tests</h2>\n<h3 id=\"entrada\">Entrada</h3>\n<ul>\n<li>A entrada consistir\u00e1 na constru\u00e7\u00e3o da \u00e1rvore bin\u00e1ria, onde cada n\u00f3 \u00e9\nrepresentado por sua refer\u00eancia na mem\u00f3ria. N\u00e3o \u00e9 necess\u00e1rio se\npreocupar com a entrada padr\u00e3o, pois a \u00e1rvore ser\u00e1 criada\nautomaticamente pelo sistema.</li>\n</ul>\n<h3 id=\"sa\u00edda\">Sa\u00edda</h3>\n<ul>\n<li>Ap\u00f3s a execu\u00e7\u00e3o do seu m\u00e9todo <code>fill()</code>, a \u00e1rvore deve ter\ntodos os n\u00f3s preenchidos corretamente com os valores de\n<code>parent</code>, <code>size</code>, <code>level</code> e\n<code>height</code>. Voc\u00ea deve garantir que, ao imprimir a \u00e1rvore, os\nvalores atribu\u00eddos estejam corretos e representem a estrutura da\n\u00e1rvore.</li>\n</ul>\n<h3 id=\"dicas-para-implementa\u00e7\u00e3o\">Dicas para Implementa\u00e7\u00e3o</h3>\n<ol type=\"1\">\n<li><strong>N\u00edvel</strong>: O n\u00edvel de um n\u00f3 pode ser calculado com base\nno n\u00edvel do n\u00f3 pai, aumentando em 1 para cada n\u00edvel descendo na\n\u00e1rvore.</li>\n<li><strong>Tamanho</strong>: O tamanho de um n\u00f3 deve ser igual a 1\n(contando ele mesmo) mais o tamanho de suas sub\u00e1rvores esquerda e\ndireita.</li>\n<li><strong>Altura</strong>: A altura de um n\u00f3 pode ser calculada como 1\n(contando ele mesmo) mais a altura da sub\u00e1rvore mais alta entre suas\nduas sub\u00e1rvores.</li>\n</ol>\n<h3 id=\"exemplos\">Exemplos</h3>\n<p>Considere a seguinte \u00e1rvore bin\u00e1ria:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre\nclass=\"sourceCode txt\"><code class=\"sourceCode default\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>        A</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>       / \\</span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>      B   C</span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>     / \\</span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    D   E</span></code></pre></div>\n<p>Ap\u00f3s a implementa\u00e7\u00e3o do m\u00e9todo <code>fill()</code>, voc\u00ea deve ser\ncapaz de acessar e imprimir as informa\u00e7\u00f5es dos n\u00f3s:</p>\n<div class=\"sourceCode\" id=\"cb2\"><pre\nclass=\"sourceCode txt\"><code class=\"sourceCode default\"><span id=\"cb2-1\"><a href=\"#cb2-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>No: A</span>\n<span id=\"cb2-2\"><a href=\"#cb2-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>Parent: NULL</span>\n<span id=\"cb2-3\"><a href=\"#cb2-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>Size: 5</span>\n<span id=\"cb2-4\"><a href=\"#cb2-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>Level: 0</span>\n<span id=\"cb2-5\"><a href=\"#cb2-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>Height: 2</span>\n<span id=\"cb2-6\"><a href=\"#cb2-6\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb2-7\"><a href=\"#cb2-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>No: B</span>\n<span id=\"cb2-8\"><a href=\"#cb2-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>Parent: A</span>\n<span id=\"cb2-9\"><a href=\"#cb2-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>Size: 3</span>\n<span id=\"cb2-10\"><a href=\"#cb2-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>Level: 1</span>\n<span id=\"cb2-11\"><a href=\"#cb2-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>Height: 1</span>\n<span id=\"cb2-12\"><a href=\"#cb2-12\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb2-13\"><a href=\"#cb2-13\" aria-hidden=\"true\" tabindex=\"-1\"></a>No: C</span>\n<span id=\"cb2-14\"><a href=\"#cb2-14\" aria-hidden=\"true\" tabindex=\"-1\"></a>Parent: A</span>\n<span id=\"cb2-15\"><a href=\"#cb2-15\" aria-hidden=\"true\" tabindex=\"-1\"></a>Size: 1</span>\n<span id=\"cb2-16\"><a href=\"#cb2-16\" aria-hidden=\"true\" tabindex=\"-1\"></a>Level: 1</span>\n<span id=\"cb2-17\"><a href=\"#cb2-17\" aria-hidden=\"true\" tabindex=\"-1\"></a>Height: 0</span>\n<span id=\"cb2-18\"><a href=\"#cb2-18\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb2-19\"><a href=\"#cb2-19\" aria-hidden=\"true\" tabindex=\"-1\"></a>No: D</span>\n<span id=\"cb2-20\"><a href=\"#cb2-20\" aria-hidden=\"true\" tabindex=\"-1\"></a>Parent: B</span>\n<span id=\"cb2-21\"><a href=\"#cb2-21\" aria-hidden=\"true\" tabindex=\"-1\"></a>Size: 1</span>\n<span id=\"cb2-22\"><a href=\"#cb2-22\" aria-hidden=\"true\" tabindex=\"-1\"></a>Level: 2</span>\n<span id=\"cb2-23\"><a href=\"#cb2-23\" aria-hidden=\"true\" tabindex=\"-1\"></a>Height: 0</span>\n<span id=\"cb2-24\"><a href=\"#cb2-24\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb2-25\"><a href=\"#cb2-25\" aria-hidden=\"true\" tabindex=\"-1\"></a>No: E</span>\n<span id=\"cb2-26\"><a href=\"#cb2-26\" aria-hidden=\"true\" tabindex=\"-1\"></a>Parent: B</span>\n<span id=\"cb2-27\"><a href=\"#cb2-27\" aria-hidden=\"true\" tabindex=\"-1\"></a>Size: 1</span>\n<span id=\"cb2-28\"><a href=\"#cb2-28\" aria-hidden=\"true\" tabindex=\"-1\"></a>Level: 2</span>\n<span id=\"cb2-29\"><a href=\"#cb2-29\" aria-hidden=\"true\" tabindex=\"-1\"></a>Height: 0</span></code></pre></div>\n<p>A correta implementa\u00e7\u00e3o do m\u00e9todo <code>fill()</code> deve garantir\nque todas as informa\u00e7\u00f5es estejam coerentes com a estrutura da\n\u00e1rvore.</p>\n</body>\n</html>",
    "upload": [
        {
            "name": "vpl_evaluate.cases",
            "contents": ">>>>>>>> INSERT test_fill\ntest_fill\n======== EXPECT\nTESTE fill\ninsert 32\ninsert 45\ninsert 37\ninsert 10\ninsert 12\nBinaryTree: Node-32{(Node-45{(Node-10{(, )}, Node-37{(, )})}, Node-12{(, )})}\nfill\nNode(32, -1, 5, 1, 3)\nNode(45, 32, 3, 2, 2)\nNode(10, 45, 1, 3, 1)\nNode(37, 45, 1, 3, 1)\nNode(12, 32, 1, 2, 1)\n<<<<<<<< FINISH\n\n\n>>>>>>>> INSERT test_fill_2\ntest_fill_2\n======== EXPECT\nTESTE fill 2\nBinaryTree: Node-32{(Node-11{(Node-6{(, )}, Node-2{(, )})}, Node-112{(Node-63{(Node-66{(, )}, Node-11{(Node--45{(, )}, Node-19{(Node--1000{(, )}, Node-1223{(, )})})})}, Node-21{(, )})})}\nfill\nNode(32, -1, 13, 1, 6)\nNode(11, 32, 3, 2, 2)\nNode(6, 11, 1, 3, 1)\nNode(2, 11, 1, 3, 1)\nNode(112, 32, 9, 2, 5)\nNode(63, 112, 7, 3, 4)\nNode(66, 63, 1, 4, 1)\nNode(11, 63, 5, 4, 3)\nNode(-45, 11, 1, 5, 1)\nNode(19, 11, 3, 5, 2)\nNode(-1000, 19, 1, 6, 1)\nNode(1223, 19, 1, 6, 1)\nNode(21, 112, 1, 3, 1)\n<<<<<<<< FINISH\n\n",
            "encoding": 0
        }
    ],
    "keep": [],
    "required": [],
    "draft": {
        "cpp": [
            {
                "name": "lib.cpp",
                "contents": "#include <iostream>\n\n// Node: classe utilizada para representar um No\n// Nao altere essa classe\nstruct Node {\n    int info; // Informacao salva pelo usuario na arvore\n    Node *left; // Ponteiro para o No filho a esquerda\n    Node *right; // Ponteiro para o No filho a direita\n\n    // CAMPOS FALTANTES QUE VOCE DEVE PREENCHER NO METODO 'FILL' //\n    Node *parent; // Ponteiro para o No pai (nao iniciado)\n    int size; // Quantidade de Nos de sua sub arvore (nao iniciado)\n    int level; // Nivel do No atual em relacao ao No raiz (nao iniciado)\n    int height; // Altura do No atual (nao iniciado)\n\n    // Construtores\n    Node(); \n    Node(int info, Node *left=NULL, Node *right=NULL);\n    \n    // Destrutor\n    ~Node();\n};\n\n// Binary Search Tree ou\n// Arvore de busca binaria\n// Altere somente os campos marcados com TODO\nstruct BinaryTree {\n    Node *root;   // Ponteiro para o No raiz da arvore\n\n    BinaryTree() {\n        root = NULL;\n    }\n\n    // Dado uma arvore onde os Nos foram iniciados com apenas os valores\n    // de 'left' e 'right', sua tarefa consiste em preencher os valores\n    // faltantes de 'parent', 'level', 'height' e 'size'.\n    void fill() {\n        // TODO: Complexidade O(n)\n        // Dica: Voce pode implementar e chamar os\n        // seguintes metodos:\n        // fill_parent(root, NULL);\n        // fill_size(root);\n        // fill_level(root, 1);\n        // fill_height(root);\n        // Mas sinta-se a vontade para alterar os metodos auxiliares.\n    }\n\n    void fill_parent(Node* current, Node* parent) {\n        // TODO: Complexidade O(n)\n        (void) parent;\n        (void) current;\n    }\n\n    int fill_size(Node* current) {\n        // TODO: Complexidade O(n)\n        (void) current;\n        return 0;\n    }\n\n\n    void fill_level(Node* current, int level) {\n        // TODO: Complexidade O(n)\n        (void) current;\n        (void) level;\n    }\n\n\n    int fill_height(Node* current) {\n        // TODO: Complexidade O(n)\n        (void) current;\n        return 0;\n    }\n\n\n    // Exemplo do FILL:\n    /*\n        T =     32\n               /  \\\n              45  12\n             /  \\\n            10  37\n    */\n    //\n    //\n    //  No45 = T.root.left\n    //  No45.parent == NULL\n    //  No45.size == -1\n    //  No45.level == -1\n    //  No45.height == -1\n    //  \n    //  T.fill()  \n    //\n    //  No45.parent == T.root\n    //  No45.size == 3\n    //  No45.level == 2\n    //  No45.height == 2\n    //  \n\n    // Deixa a lista vazia, com zero elementos\n    void clear() {\n        _clear(root);\n        root = NULL;\n    }\n\n    void _clear(Node* current) {\n        if(current == NULL) return;\n        _clear(current->left);\n        _clear(current->right);\n        delete current;\n    }\n\n    // Devolve true se vazia e false caso contrario\n    bool empty() {\n        return root == NULL;\n    }\n\n    // Printa as informacoes da lista\n    void print() {\n        std::cout << \"BinaryTree: \";\n        _print(root);\n        std::cout << std::endl;\n    }\n\n    void _print(Node *current) {\n        if(current != NULL) {\n            std::cout << \"Node-\" << current->info << \"{(\";\n            _print(current->left);\n            std::cout << \", \";\n            _print(current->right);\n            std::cout << \")}\";\n        }\n    }\n};\n",
                "encoding": 0
            },
            {
                "name": "main.cpp",
                "contents": "// Arquivo de execucao\n#include <iostream>\n#include <map>\n//#include \"solution_lib.cpp\"\n#include \"lib.cpp\"\n\nusing std::cout;\nusing std::endl;\n\nbool LOG_ALLOCATED = false;\nstd::map<void*, int> allocated_nodes_status = {};\nstd::map<int, int> mapa = {};\nconst int ALLOCATED = 1;\nconst int DELETED = 2;\n\n// Salvar Nos alocados\nNode::Node() {\n    allocated_nodes_status[this] = ALLOCATED;\n}\n\nNode::Node(int info, Node* left, Node* right) {\n    allocated_nodes_status[this] = ALLOCATED;\n    this->info = info;\n    this->left = left;\n    this->right = right;\n    \n    this->parent = nullptr;\n    this->height = -1;\n    this->size = -1;\n    this->level = -1;\n}\nNode::~Node() {\n    allocated_nodes_status[this] = DELETED;\n}\n\ntemplate <typename K, typename V>\nvoid printMap(const std::map<K, V>& m) {\n    for (const auto& pair : m) {\n        std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\n    }\n}\n\n/////////////// TESTES AUXILIARES /////////////\n\nvoid print_node(Node *node) {\n    if(node == nullptr) {\n        cout << \"Node(empty)\" << endl;\n    } else {\n        int parent_info = -1;\n        if(node->parent != nullptr) {\n            parent_info = node->parent->info;\n        }\n        cout << \"Node(\" << node->info << \", \"\n                        << parent_info << \", \"\n                        << node->size << \", \"\n                        << node->level << \", \"\n                        << node->height << \")\"\n                        << endl;\n    }\n}\n\nvoid print_tree(Node *current) {\n    if(current != nullptr) {\n        print_node(current);\n        print_tree(current->left);\n        print_tree(current->right);\n    }\n}\n\n/*\n Exemplo:\n \n    T =   32\n         /  \\\n        45  12\n       /  \\\n      10  37\n*/\n\n/////////////// TESTE FILL ///////////////\n\nvoid test_fill() {\n    cout << \"TESTE fill\" << endl;\n    BinaryTree tree;\n    Node *node32 = new Node(32);\n    Node *node45 = new Node(45);\n    Node *node10 = new Node(10);\n    Node *node37 = new Node(37);\n    Node *node12 = new Node(12);\n\n    cout << \"insert 32\" << endl; tree.root = node32;\n    cout << \"insert 45\" << endl; node32->left = node45;\n    cout << \"insert 37\" << endl; node45->right = node37;\n    cout << \"insert 10\" << endl; node45->left = node10;\n    cout << \"insert 12\" << endl; node32->right = node12;\n    tree.print();\n    \n    cout << \"fill\" << endl; tree.fill();\n\n    print_node(node32);\n    print_node(node45);\n    print_node(node10);\n    print_node(node37);\n    print_node(node12);\n}\n\n\n/////////////// TESTE FILL 2 ///////////////\n\nvoid test_fill_2() {\n    cout << \"TESTE fill 2\" << endl;\n    BinaryTree tree;\n    Node *root = new Node(32,\n        new Node(11,\n            new Node(6, NULL, NULL),\n            new Node(2, NULL, NULL)\n        ),\n        new Node(112,\n            new Node(63,\n                new Node(66, NULL, NULL),\n                new Node(11,\n                    new Node(-45, NULL, NULL),\n                    new Node(19,\n                        new Node(-1000, NULL, NULL),\n                        new Node(1223, NULL, NULL)\n                    )\n                )\n            ),\n            new Node(21, NULL, NULL)\n        )\n    );\n\n    tree.root = root;\n    tree.print();\n    \n    cout << \"fill\" << endl; tree.fill();\n\n    print_tree(tree.root);\n}\n\n\n/////////////// FIM TESTES ///////////////\n\nint main() {\n    std::string input;\n    std::cin >> input;\n\n    if(input == \"test_fill\") test_fill();\n    if(input == \"test_fill_2\") test_fill_2();\n}\n",
                "encoding": 0
            }
        ]
    }
}
